<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
      <title>Introduction | Astra RPG Health </title>
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <meta name="title" content="Introduction | Astra RPG Health ">
      
      
      <link rel="icon" href="../images/astra-rpg-ico.ico">
      <link rel="stylesheet" href="../public/docfx.min.css">
      <link rel="stylesheet" href="../public/main.css">
      <meta name="docfx:navrel" content="../toc.html">
      <meta name="docfx:tocrel" content="toc.html">
      
      <meta name="docfx:rel" content="../">
      
      
      
      <meta name="loc:inThisArticle" content="In this article">
      <meta name="loc:searchResultsCount" content="{count} results for &quot;{query}&quot;">
      <meta name="loc:searchNoResults" content="No results for &quot;{query}&quot;">
      <meta name="loc:tocFilter" content="Filter by title">
      <meta name="loc:nextArticle" content="Next">
      <meta name="loc:prevArticle" content="Previous">
      <meta name="loc:themeLight" content="Light">
      <meta name="loc:themeDark" content="Dark">
      <meta name="loc:themeAuto" content="Auto">
      <meta name="loc:changeTheme" content="Change theme">
      <meta name="loc:copy" content="Copy">
      <meta name="loc:downloadPdf" content="Download PDF">

      <script type="module" src="./../public/docfx.min.js"></script>

      <script>
        const theme = localStorage.getItem('theme') || 'auto'
        document.documentElement.setAttribute('data-bs-theme', theme === 'auto' ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') : theme)
      </script>

  </head>

  <body class="tex2jax_ignore" data-layout="" data-yaml-mime="">
    <header class="bg-body border-bottom">
      <nav id="autocollapse" class="navbar navbar-expand-md" role="navigation">
        <div class="container-xxl flex-nowrap">
          <a class="navbar-brand" href="../index.html">
            <img id="logo" class="svg" src="../images/logo-astra.svg" alt="Astra RPG Health">
            Astra RPG Health
          </a>
          <button class="btn btn-lg d-md-none border-0" type="button" data-bs-toggle="collapse" data-bs-target="#navpanel" aria-controls="navpanel" aria-expanded="false" aria-label="Toggle navigation">
            <i class="bi bi-three-dots"></i>
          </button>
          <div class="collapse navbar-collapse" id="navpanel">
            <div id="navbar">
              <form class="search" role="search" id="search">
                <i class="bi bi-search"></i>
                <input class="form-control" id="search-query" type="search" disabled placeholder="Search" autocomplete="off" aria-label="Search">
              </form>
            </div>
          </div>
        </div>
      </nav>
    </header>

    <main class="container-xxl">
      <div class="toc-offcanvas">
        <div class="offcanvas-md offcanvas-start" tabindex="-1" id="tocOffcanvas" aria-labelledby="tocOffcanvasLabel">
          <div class="offcanvas-header">
            <h5 class="offcanvas-title" id="tocOffcanvasLabel">Table of Contents</h5>
            <button type="button" class="btn-close" data-bs-dismiss="offcanvas" data-bs-target="#tocOffcanvas" aria-label="Close"></button>
          </div>
          <div class="offcanvas-body">
            <nav class="toc" id="toc"></nav>
          </div>
        </div>
      </div>

      <div class="content">
        <div class="actionbar">
          <button class="btn btn-lg border-0 d-md-none" type="button" data-bs-toggle="offcanvas" data-bs-target="#tocOffcanvas" aria-controls="tocOffcanvas" aria-expanded="false" aria-label="Show table of contents">
            <i class="bi bi-list"></i>
          </button>

          <nav id="breadcrumb"></nav>
        </div>

        <article data-uid="">

<div class="NOTE">
<h5>Note</h5>
<p>Join the Astra RPG Discord server!<br>
There is now a dedicated <strong>Discord server</strong> for Astra RPG Framework and its extensions.
Join to <strong>receive notifications</strong> about new extension releases and important updates, to <strong>ask for new features</strong>, <strong>report bugs</strong>, <strong>share ideas</strong>, and <strong>showcase your Astra creations</strong> with other developers.<br>
<span style="font-size:1.18em; font-weight:600;">ðŸ’¬ Join the Discord Server: <a href="https://discord.gg/nJVRMkGrZg">https://discord.gg/nJVRMkGrZg</a></span></p>
</div>
<h1 id="introduction">Introduction</h1>
<p>Astra RPG Framework is a lightweight, modular framework that takes a different approach compared to other RPG solutions. While many existing frameworks offer comprehensive, pre-built systems, they often come with steep learning curves and rigid structures that can limit your creative freedom. Astra RPG Framework instead focuses on providing a clean, flexible foundation that you can shape to your exact needs.</p>
<p>Key advantages:</p>
<ul>
<li><strong>Modular Architecture</strong>: Pay just for what you need. Astra RPG Framework serves as the foundation, with additional packages building upon it to extend functionality in a modular way.</li>
<li><strong>True Flexibility</strong>: Unlike more rigid frameworks, Astra RPG Framework defines only essential concepts, letting you model any game system without being constrained by pre-made assumptions. The limitations are minimal.</li>
<li><strong>Gentle Learning Curve</strong>: Start creating immediately with intuitive, inspector-driven workflows, avoiding the complexity of larger frameworks.</li>
<li><strong>100% Inspector-Driven</strong>: Make changes and balance your game without touching code. Game designers can tweak values through ScriptableObjects in real-time, even during play mode, without needing recompilation. This also enables rapid testing and debugging by allowing instant value adjustments.</li>
<li><strong>Minimal Lock-in</strong>: The framework's lightweight nature means you're never locked into specific game design patterns.</li>
</ul>
<p>Whether you're creating a traditional RPG, a roguelike/roguelite, an MMO, or even a game with unique mechanics, Astra RPG Framework adapts to your needs without forcing you into predetermined patterns. It provides essential building blocks for managing attributes, statistics, levels, and classes, along with powerful systems for controlling stat growth through customizable formulas, handling game events, and implementing scaling calculations. This lets you focus on the creative aspects of game development while having precise control over how your game elements evolve and interact.</p>
<h2 id="vocabulary-of-astra-rpg-framework">Vocabulary of Astra RPG Framework</h2>
<p>The package is developed around the concept of <em>entity</em>, so let's clarify what we mean by this term in the context of Astra RPG Framework. In its most minimal version, an entity is a <code>GameObject</code> that has a set of statistics. Optionally, an entity can have attributes, can level up, and can have a class.
Let's clarify what we mean by each mentioned term.</p>
<h3 id="statistics-stat">Statistics (Stat)</h3>
<p>A statistic is a value that quantifies an aspect of the entity. The meaning of this aspect is solely due to the concept it refers to.</p>
<h4 id="examples">Examples</h4>
<p>In an RPG, a statistic can be <code>physical damage</code>. The concept of physical damage refers the player to the amount of damage inflicted by physical attacks, whether with weapons or without. Other statistics can be <code>ability power</code>, <code>defense</code>, <code>speed</code>, <code>armor penetration</code>, <code>range</code>, etc.</p>
<h3 id="attributes">Attributes</h3>
<p>An attribute is a value that can influence the value of one or more statistics. The weight of its influence on the statistics can be variable.</p>
<h4 id="examples-1">Examples</h4>
<p>In an RPG, attributes can be: <code>strength</code>, <code>dexterity</code>, <code>intelligence</code>, <code>constitution</code>, etc. Considering the previous example of statistics, <code>strength</code> could influence <code>physical damage</code>, <code>dexterity</code> would increase <code>speed</code>, <code>intelligence</code> would increase <code>ability power</code>, and <code>constitution</code> would increase <code>defense</code>.</p>
<h3 id="experience-and-level">Experience and Level</h3>
<p>The entity can gain experience and level up. This functionality is used by the class to express how attributes and statistics grow with levels, for that particular class.</p>
<h3 id="class">Class</h3>
<p>The class is associated with a set of statistics and optionally a set of attributes. The class describes how statistics and attributes vary with levels.</p>
<h4 id="examples-2">Examples</h4>
<p>In RPGs most common classes are: <code>warrior</code>, <code>rogue</code>, <code>mage</code>, <code>paladin</code>, and so on. These classes have different attribute values. For example, a warrior will have more <code>strength</code> and <code>constitution</code> than a mage. The <code>rogue</code> might have the highest <code>dexterity</code>, etc.</p>
<h2 id="how-is-astra-rpg-framework-organized-and-how-does-it-work">How is Astra RPG Framework organized and how does it work?</h2>
<h3 id="-entity"><img src="../images/AstraRPG/entity-core.png" alt="EntityCore2" width="30" class="icon-background"> Entity</h3>
<p>A <code>GameObject</code> becomes an entity once the <code>EntityCore</code> and <code>EntityStats</code> <code>MonoBehaviour</code>s (Mono) are added to it. <code>EntityCore</code> comes with a built-in <code>EntityLevel</code> (plain C# <code>class</code>) that manages the experience and the level of the entity.</p>
<h3 id="-stat"><img src="../images/AstraRPG/stat.png" alt="stat" width="30" class="icon-background"> Stat</h3>
<p>A <code>Stat</code> is a class that derives from <code>ScriptableObject</code> (SO) and represents a statistic in the game. Each statistic has a name (the name given to the SO instance of the created <code>Stat</code>), and we can choose whether to provide it with a maximum and/or minimum value. Additionally, we can define how that statistic grows or is reduced, depending on certain <code>Attributes</code>.</p>
<h3 id="-statset"><img src="../images/AstraRPG/stat-set.png" alt="stat set" width="30" class="icon-background"> StatSet</h3>
<p>A <code>StatSet</code> is a class derived from ScriptableObject that defines a collection of <code>Stat</code>s. Stat sets can be composed by combining other sub-stat sets, enabling hierarchical organization and easy reuse of statistics among different entities or classes.</p>
<h3 id="-entitystats"><img src="../images/AstraRPG/entity-stats.png" alt="entity stats" width="30" class="icon-background"> EntityStats</h3>
<p><code>EntityStats</code> allows us to configure:</p>
<ul>
<li>the base statistics</li>
<li>the flat modifiers</li>
<li>the <em>StatToStat</em> modifiers</li>
<li>the percentage modifiers
We will see what these modifiers are in the section <a href="workflows.html#understanding-stat-modifier-types">Understanding Stat Modifier Types</a>.</li>
</ul>
<p>The base statistics can be <em>fixed</em>, or instead derive from a class if the entity has one assigned. If we use the fixed ones, we must also provide a <code>StatSet</code>, while if we use those of a class, the class's <code>StatSet</code> will be used. If the entity levels up and we want its statistics to grow with levels, we are forced to use a class, as the <em>fixed</em> statistics are immutable.</p>
<h3 id="-class"><img src="../images/AstraRPG/class.png" alt="class" width="30" class="icon-background"> Class</h3>
<p><code>Class</code> derives from SO and represents a game class. Each class has a name, a <code>GrowthFormula</code> that defines how the base Max HP grows with levels, a <code>StatSet</code>, optionally an <code>AttributeSet</code>, and associates each <code>Stat</code> of the provided StatSet with a <code>GrowthFormula</code> that describes how the statistic varies with levels. Similarly, if an <code>AttributeSet</code> is provided, it will be possible to associate a <code>GrowthFormula</code> for each <code>Attribute</code> present in the set, to describe how the attributes vary with levels.</p>
<h3 id="-entityclass"><img src="../images/AstraRPG/entity-class.png" alt="entity class" width="30" class="icon-background"> EntityClass</h3>
<p><code>EntityClass</code> derives from Mono and allows us to assign a <code>Class</code> to our entity.</p>
<h3 id="-attribute"><img src="../images/AstraRPG/attribute.png" alt="attribute" width="30" class="icon-background"> Attribute</h3>
<p>An <code>Attribute</code> is a class that derives from SO and represents an attribute in the game. Each attribute has a name and, like statistics, can have a maximum and minimum value.</p>
<h3 id="-attributeset"><img src="../images/AstraRPG/attribute-set.png" alt="stat set" width="30" class="icon-background"> AttributeSet</h3>
<p>An <code>AttributeSet</code> is a class that derives from SO and defines a set of <code>Attribute</code>s.</p>
<h3 id="-entityattributes"><img src="../images/AstraRPG/entity-attributes.png" alt="entity attributes" width="30" class="icon-background"> EntityAttributes</h3>
<p>Optionally, we can add the Mono <code>EntityAttributes</code> to our entity if we want to give it attributes. <code>EntityAttributes</code> allows us to specify how many attribute points to provide at each new level. These points can be spent on various attributes to increase their value. For <code>EntityAttributes</code> we can configure:</p>
<ul>
<li>the base attributes</li>
<li>the flat modifiers</li>
<li>the percentage modifiers
Similarly to <code>EntityStats</code>, we can decide whether the base attributes are <em>fixed</em> or if they instead derive from the class associated with <code>EntityClass</code>.</li>
</ul>
<h3 id="-growth-formula"><img src="../images/AstraRPG/growth-fo.png" alt="growth formula" width="30" class="icon-background"> Growth Formula</h3>
<p>To express how <code>Stats</code>, <code>Attributes</code>, Max HP, and the experience required to level up vary at each level, we can use instances of <code>GrowthFormula</code>. This is a class that derives from SO and allows us to define a mathematical function, or a system of functions, that describe how a value changes as levels increase. We will see in more detail how to define a <code>GrowthFormula</code> in the <a href="workflows.html#growth-formulas">Growth Formulas</a> section.</p>
<h3 id="-scaling-formulas"><img src="../images/AstraRPG/scaling-fo.png" alt="scaling formula" width="30" class="icon-background"> Scaling Formulas</h3>
<p>Scaling formulas provide a flexible way to define how values such as damage, healing, or other effects are calculated based on one or more attributes or stats. They allow you to combine base values (which can be constant or level-dependent) with contributions from various stats and attributes, each weighted by customizable scaling components.</p>
<h3 id="-scaling-components"><img src="../images/AstraRPG/stat-scaling-component.png" alt="stats scaling component" width="30" class="icon-background"><img src="../images/AstraRPG/attribute-scaling-component.png" alt="attribute scaling component" width="30" class="icon-background"> Scaling components</h3>
<p>Specify how much a particular stat or attribute influences the final value of the scaling formula, enabling complex and dynamic calculations for abilities, equipment, or other game mechanics. This modular approach lets you easily adjust and extend scaling logic to fit your game's needs.</p>
<h3 id="-game-events"><img src="../images/AstraRPG/event.png" alt="game event" width="30" class="icon-background"> Game Events</h3>
<p>Game events are ScriptableObjects that allow you to implement the Observer pattern in your game. They provide a way to decouple systems by broadcasting notifications when something happens (such as a player jumping, leveling up, or taking damage). Listeners can subscribe to these events and react accordingly, all through inspector-driven workflows. Game events can carry context parameters, making them flexible for a wide range of use cases.</p>
<h3 id="-game-event-generators"><img src="../images/AstraRPG/event-gen.png" alt="game event generator" width="30" class="icon-background"> Game Event Generators</h3>
<p>Game Event Generators are ScriptableObjects that let you define custom game events with up to four context parameters. They automate the creation of event and listener classes, making it easy to extend your event system for complex gameplay scenarios. You can specify parameter types and documentation, and generate code and assets directly from the inspector.</p>
<h2 id="how-is-astra-rpg-framework-implemented">How is Astra RPG Framework implemented?</h2>
<p>The package is developed around a Scriptable Objects architecture inspired by the <a href="https://www.youtube.com/watch?v=raQ3iHhE_Kk&amp;ab_channel=Unity">GDC talk of Ryan Hipple</a>. In a nutshell, the main benefits provided by this architecture are:</p>
<ul>
<li><strong>encapsulation</strong>: separation of game logic from data. Game logic code shouldn't mix with data. All data is nicely wrapped withing SO instances</li>
<li><strong>game designers friendly</strong>: game designers can make changes and balancements from the inspector without touching the code</li>
<li><strong>greater reusability</strong>: most features are <code>ScriptableObject</code>s that can be reused by many components</li>
<li><strong>greater testability</strong>: being data separated from code, is easier to isolate and fix bugs. Moreover, SO events can be raised with ease at the press of a button from the inspector interface, easing and speeding up debugging even further.</li>
</ul>
<h2 id="flexibility-of-astra-rpg-framework">Flexibility of Astra RPG Framework</h2>
<p>Although the package is specifically designed for RPG games or games with progression systems, its flexibility allows it to be used in almost any game. As it allows creating attributes like <code>strength</code>, <code>dexterity</code>, <code>agility</code>, etc., and statistics such as <code>physical attack</code>, <code>magic power</code>, <code>physical defense</code>, etc., in RPG, Roguelike, MMO games, etc., nothing prevents it from being used, for example, to implement a firearm. The attributes could be <code>weight</code>, <code>size</code>, <code>ergonomics</code>, etc., and the statistics <code>recoil</code>, <code>handling</code>, <code>stability</code>, <code>intimidation</code>, etc. Attributes can influence statistics. A heavier weapon could reduce <code>handling</code> but increase <code>stability</code>. A larger weapon could reduce <code>handling</code> but increase <code>intimidation</code>. A more ergonomic weapon could reduce <code>recoil</code> and increase <code>handling</code>. And so on... The weapon's levels, if present, influence the attributes and statistics, progressively improving them. Classes could represent weapon types (assault rifles, snipers, shotguns, etc.), and each class could have its own set of dedicated attributes and statistics. For example, shotguns could have, in addition to the aforementioned ones, the <code>barrel length</code> attribute that influences the <code>pellet spread</code> statistic.</p>

</article>


        <div class="next-article d-print-none border-top" id="nextArticle"></div>

      </div>

      <div class="affix">
        <nav id="affix"></nav>
      </div>
    </main>

    <div class="container-xxl search-results" id="search-results"></div>

    <footer class="border-top text-secondary">
      <div class="container-xxl">
        <div class="flex-fill">
          <span>Made with <a href="https://dotnet.github.io/docfx">docfx</a></span>
        </div>
      </div>
    </footer>
  </body>
</html>
