{
  "MD/advanced-topics.html": {
    "href": "MD/advanced-topics.html",
    "title": "Advanced topics | Astra RPG Health",
    "summary": "Advanced topics Presentation layer and localization \uD83C\uDFF7️ Version 1.2.0+ The framework focuses on the business logic of RPG systems and does not impose any specific presentation layer or localization strategy. You are free to implement your own UI and localization solutions that best fit your project's needs. However, the framework provides basic support for the presentation layer by allowing you to define display names for attributes, statistics, and classes. These display names can be used in your UI to present information to players in a user-friendly manner. In fact, ScriptableObjects names are convenient and quick to use during development, but they are not ideal for presentation to players. By defining display names, you can separate the internal representation of your RPG systems from the user-facing presentation layer. IDisplaySONameProvider The framework includes the IDisplaySONameProvider interface, which can be implemented by UI components to display readable names for attributes, statistics, and classes: public interface IDisplaySONameProvider<in T> where T : ScriptableObject { string GetDisplayName(T asset); } The framework provides a default implementation of this interface, DefaultDisplaySONameProvider, which retrieves the ScriptableObject's name and returns it as the display name. You can use this default implementation or create your own custom implementation to suit your localization needs. The attributes are a particular as in many RPGs they can either be presented with the extended name (e.g., \"Strength\") or with an abbreviation (e.g., \"STR\"). To accommodate this, the framework provides the DefaultAttributeCompactDisplaySONameProvider implementation, which returns the first three letters, capitalized, as the display name for a certain attribute. Using custom display name providers To use a custom display name provider, you can instantiate your implementation in your own scripts, or rely on the TypeSelectable attribute provided by the framework to select the implementation from the Unity inspector. For example: [SerializeReference, TypeSelectable(typeof(DefaultDisplaySONameProvider<Attribute>))] private IDisplaySONameProvider<Attribute> _attributeDisplayNameProvider; TypeSelectable is an experimental feature of the framework that allows you to select a concrete implementation of an interface from the Unity inspector. The parameter passed to TypeSelectable is the default implementation that will be selected when the inspector is first displayed. You can then choose a different implementation from a dropdown list in the inspector. If you take a look at the demo scene, if you select the AttributesContainer GameObject inside WarriorCanvas -> HeroPanel in the hierarchy, you will see a Attribute Display So Name Provider field in the inspector under the Values Reader component. This field uses the TypeSelectable attribute to allow you to choose between the default and compact display name providers for attributes. The implementation passed as parameter to TypeSelectable will be instantiated automatically by the framework during script compilation. Moreover, the framework will show it in the inspector, in the dropdown list, as the Default option under None. During Play Mode, you can switch between the different implementations to see how the display names change in the UI of the sample scene. With the default implementation, the attributes will be displayed with their full names: With the compact implementation, the attributes will be displayed with their abbreviations:"
  },
  "MD/changelog.html": {
    "href": "MD/changelog.html",
    "title": "Changelog | Astra RPG Health",
    "summary": "Changelog All notable changes to this project will be documented in this file. The format is based on Keep a Changelog. [1.3.0] - 2025-12-16 Added Runtime Features Added PRV[N] and AT[N] keywords for growth formulas' expressions. PRV[N]: Represents the n-previous Growth Formula value. For example, PRV[3] at level 8 would return the Growth Formula value at level 5. AT[N]: Represents the Growth Formula value at a specific level N. For example, AT[10] would return the Growth Formula value at level 10. BoundedValue.Clamp now supports also clamping of double values. For now is used internally by the framework and is reserved for future use is Astra RPG Health. Editor Features Added support for enum formatting in InspectorTypography. Added utility to provide compact representation of large numbers in the editor (e.g., 1.5K, 4M). Reserved for future use in Astra RPG Health. Changed Runtime Features Changed the internal AttributePointsTracker used by EntityAttributes to track spendable attribute points. EntityPointsTracker replaces the legacy tracker, and relies on a new AttributePortfolio to manage the allocation of attribute points to attributes. This new system is more readable, more robust, and more maintainable. The old system is left for backward compatibility. By updating the framework to this version, existing projects will automatically migrate to the new system. Fixed Runtime Features Fixed Round Robin Strategy for attribute points removal on level down or reset to level 1. [1.2.0] - 2025-11-25 Added Runtime Features Added OnLevelDownEvent Game Event. This event is triggered whenever an entity levels down, allowing you to respond to level down events in your game. Added XP deduction feature. Now you can deduct XP from an entity using the EntityCore.Level.RemoveExp(long amount) method. This will also handle level downs if the deducted XP causes the entity to drop below the current level's XP threshold. Triggers the OnLevelDownEvent once for each level the entity drops. Added reset to level 1 feature. You can now reset an entity's level and XP to level 1 using the EntityCore.Level.ResetToLevelOne() method. This will set the entity's level to 1 and XP to 0. Triggers the OnLevelDownEvent once for each level the entity drops. Added basic support for statistics, attributes, and classes names presentation. This includes: IDisplaySONameProvider<in T> where T : ScriptableObject interface for providing custom display names for ScriptableObjects. DefaultDisplaySONameProvider<T> class that implements the above interface and returns the ScriptableObject's name as the display name. DefaultAttributeCompactDisplaySONameProvider class that provides compact display names for attributes (e.g., \"Str\" for \"Strength\"). This one simply takes the first three letters of the attribute's name, capitalize them, and return that as the display name. You can implement your own display name providers by implementing the IDisplaySONameProvider<T> interface to provide custom display names for your statistics, attributes, and classes or to use localization systems. Editor Features Added Read Only (RO) property in InspectorTypography. Marks a field in the inspector as read only, in the sense that the component automatically manages it, and the user should not manually edit any associate LongVar/IntVar associated values. Currently reserved for future use. Added IValidatable interface. Used by the framework to propagate validation events to depending objects. Used to ensure that when a MonoBehaviour/ScriptableObject is validated in the inspector, all depending objects are also validated to ensure data consistency. Added TypeSelectionMenu. Provides a reusable editor context menu to pick a concrete type derived from a given base type. Configurable display (optional \"None\" or \"Default\" entries, optional name trimming, exclusion of test types, extra filters). Returns the chosen type via a callback so callers can create or clear instances accordingly. Added [TypeSelectable] attribute for use on [SerializeReference] fields; supports an optional DefaultType to present a \"Default\" choice. Shows also \"None\" to clear the reference. Added SerializeReferenceDrawer custom property drawer. New editor PropertyDrawer showing current concrete type and a Select button for managed references. Opens centralized TypeSelectionMenu, supports choosing None, Default or concrete types and creates/assigns instances. Added SerializeReferenceInitializer. Runs in the editor to ensure [SerializeReference] fields marked with [TypeSelectable] that declare a default type are populated when scenes/prefabs are opened or on demand (during script compilation). Automatically instantiates and assigns default instances where fields are null, provides a menu command to initialize all applicable fields, and marks modified assets/scenes as dirty. Samples Added ExpUtils MonoBehaviour. Adds utility methods that can be invoked from the Unity Editor (in play mode) to add or remove XP from an entity for testing purposes. Changed Runtime SoSetScalingComponentBase now logs a warning if no entity set is assigned during the lookup of values to use for scaling calculations. AttributeScalingComponent and StatScalingComponent now return 0 as the scaled value if no entity set is assigned, instead of rasing an error. This behavior allows for more flexible setups with entities with different sets of attributes/stats. The warning logged by the base class will help identify potential misconfigurations. Marked OnEntityLevelUp and OnEntityLevelDown events in EntityCore as required (red *). Such methods are becoming crucial for the correct functioning of the various components of the framework. Therefore, it's important to ensure that these events are properly assigned. Entities that are missing these events will raise an error during their Start() method. Editor Improved hot-reloading support for StatSet and AttributeSet. Attributes of AttributeSet are not \"Re-play\" (yellow R) any more. This means that it supports changes (addition/removal) of attributes in the AttributeSet without exiting play-mode. Improved InspectorTypography class. Now it supports also property drawn within GUI rects. Samples ValuesReader and ValueEntry now use [SerializeReference] and [TypeSelectable] attributes for allowing easier selection of the presentation strategy for each value entry (IDisplaySONameProvider implementation). Deprecated Deprecated DerivedTypePicker in favor of the new TypeSelectionMenu system. Use the new system for better type selection in the editor. DerivedTypePicker will be removed in future releases. Fixed Added missing invalidation of the cached values for the statistics in EntityStats.OnEnable() method. Fixed SetTotalCurrentExp that was not raising level up and level down events when appropriate. Fixed the assignment of total available attribute points. Previously, this was handled only in OnValidate, which caused issues in builds (where editor-only code is stripped). Initialization is now also performed in EntityCore.Start(). Additionally, total available attribute points are now updated within AddPoints(), ensuring they are correctly recalculated whenever points are added—not only during Init(). [1.1.2] - 2025-11-12 Changed Updated the \"Example scene and instances\" samples. Now by default the Hero prefab uses a IntVar for the attribute spendable points per level. This makes more consistent the amount of spendable attribute points acquired by each character on level up Updated offline docs with Installation Guide section [1.1.1] - 2025-11-06 Changed Updated the links in package.json to match the new docs URL [1.1.0] - 2025-11-06 Changed Updated branding from \"SOAP RPG Framework\" to \"Astra RPG Framework\" IMPORTANT: Refer to the migration guide for updating existing projects that used the previous version. UPM package name changed to \"com.electricdrill.astra-rpg-framework\". UPM package display name changed to \"Astra RPG Framework\". Namespaces updated to reflect new branding: \"ElectricDrill.AstraRPGFramework\". Menu paths in Unity Editor updated to \"Astra RPG Framework\". Deprecated _includedStatSets field in StatSet will become an internal property in future releases. [1.0.0] - 2025-10-30 Added Initial release of SOAP RPG Framework. ScriptableObject-based toolkit for core RPG mechanics. MonoBehaviour-based components for easy integration. ScriptableObject Features Statistics & Attributes: Define core stats like Strength and Intelligence, as well as derived attributes like Health or Mana. StatSets & AttributeSets: Group related stats and attributes together for organization. Sets can be nested for complex structures. Experience & Leveling System: Custom experience curves and character progression. Classes: Define character classes with unique progressions and abilities. Progression System: Control how stats and attributes grow as characters level up. Scaling Formulas: Custom formulas to calculate final values of stats and attributes. Scaling Components: Modular scaling formulas reusable across stats and attributes. Game Events: Design and trigger custom game events. Growth Formulas: Determine how values progress based on a character's level. Game Event Generators: Define custom game event types. Variables: Use Long and Int variables as ScriptableObjects for persistent data storage. MonoBehaviour Features EntityCore: Manage a character's core data, including experience and level. EntityStats & EntityAttributes: Assign statistics and attributes to any entity. Components can retrieve values from the assigned EntityClass based on level. EntityClass: Assign a class to an entity, linking it to specific progression paths. API & Modifiers Comprehensive API for advanced customization (see API Docs). Dynamic application of modifiers to stats and attributes: Flat & Percentage Modifiers for attributes. Flat, Percentage, & Stat-to-Stat Modifiers for statistics."
  },
  "MD/installation-instructions.html": {
    "href": "MD/installation-instructions.html",
    "title": "Installation instructions | Astra RPG Health",
    "summary": "Installation instructions Importing Astra RPG Framework and its samples From the package manager, import Astra RPG Framework. You can find the package in the \"My Assets\" section. After importing, head to the \"In Project\" section, always in the Package Manager, and click on \"AstraRPGFramework\". Click on the \"Samples\" tab and import the samples you desire. Find out more about the samples in the Samples documentation. If you imported the \"Example scene and instances\" samples you need to import also TextMeshPro Essentials. Click on \"Window > TextMeshPro > Import TMP Essential Resources\". Unity 6.2 and above extra steps for having the sample scene working If you are using Unity 6.2 or above, and you imported the \"Example scene and instances\" samples, you need to do the following extra steps to have the sample scene working: Open the \"SampleScene\" scene located in \"Assets/Samples/AstraRPGFramework/[version of the package]/Example scene and instances/SampleScene\". Select the \"EventSystem\" GameObject in the Hierarchy. In the Inspector, find the \"Standalone Input Module\" component. You should see an error like: Click on \"Replace with InputSystemUIInputModule\". The sample scene should now work correctly. I am working on a fix to avoid having to do these extra steps in future versions of the package, while preserving compatibility with Unity versions below 6.2."
  },
  "MD/introduction.html": {
    "href": "MD/introduction.html",
    "title": "Introduction | Astra RPG Health",
    "summary": "Note Join the Astra RPG Discord server! There is now a dedicated Discord server for Astra RPG Framework and its extensions. Join to receive notifications about new extension releases and important updates, to ask for new features, report bugs, share ideas, and showcase your Astra creations with other developers. \uD83D\uDCAC Join the Discord Server: https://discord.gg/nJVRMkGrZg Introduction Astra RPG Framework is a lightweight, modular framework that takes a different approach compared to other RPG solutions. While many existing frameworks offer comprehensive, pre-built systems, they often come with steep learning curves and rigid structures that can limit your creative freedom. Astra RPG Framework instead focuses on providing a clean, flexible foundation that you can shape to your exact needs. Key advantages: Modular Architecture: Pay just for what you need. Astra RPG Framework serves as the foundation, with additional packages building upon it to extend functionality in a modular way. True Flexibility: Unlike more rigid frameworks, Astra RPG Framework defines only essential concepts, letting you model any game system without being constrained by pre-made assumptions. The limitations are minimal. Gentle Learning Curve: Start creating immediately with intuitive, inspector-driven workflows, avoiding the complexity of larger frameworks. 100% Inspector-Driven: Make changes and balance your game without touching code. Game designers can tweak values through ScriptableObjects in real-time, even during play mode, without needing recompilation. This also enables rapid testing and debugging by allowing instant value adjustments. Minimal Lock-in: The framework's lightweight nature means you're never locked into specific game design patterns. Whether you're creating a traditional RPG, a roguelike/roguelite, an MMO, or even a game with unique mechanics, Astra RPG Framework adapts to your needs without forcing you into predetermined patterns. It provides essential building blocks for managing attributes, statistics, levels, and classes, along with powerful systems for controlling stat growth through customizable formulas, handling game events, and implementing scaling calculations. This lets you focus on the creative aspects of game development while having precise control over how your game elements evolve and interact. Vocabulary of Astra RPG Framework The package is developed around the concept of entity, so let's clarify what we mean by this term in the context of Astra RPG Framework. In its most minimal version, an entity is a GameObject that has a set of statistics. Optionally, an entity can have attributes, can level up, and can have a class. Let's clarify what we mean by each mentioned term. Statistics (Stat) A statistic is a value that quantifies an aspect of the entity. The meaning of this aspect is solely due to the concept it refers to. Examples In an RPG, a statistic can be physical damage. The concept of physical damage refers the player to the amount of damage inflicted by physical attacks, whether with weapons or without. Other statistics can be ability power, defense, speed, armor penetration, range, etc. Attributes An attribute is a value that can influence the value of one or more statistics. The weight of its influence on the statistics can be variable. Examples In an RPG, attributes can be: strength, dexterity, intelligence, constitution, etc. Considering the previous example of statistics, strength could influence physical damage, dexterity would increase speed, intelligence would increase ability power, and constitution would increase defense. Experience and Level The entity can gain experience and level up. This functionality is used by the class to express how attributes and statistics grow with levels, for that particular class. Class The class is associated with a set of statistics and optionally a set of attributes. The class describes how statistics and attributes vary with levels. Examples In RPGs most common classes are: warrior, rogue, mage, paladin, and so on. These classes have different attribute values. For example, a warrior will have more strength and constitution than a mage. The rogue might have the highest dexterity, etc. How is Astra RPG Framework organized and how does it work? Entity A GameObject becomes an entity once the EntityCore and EntityStats MonoBehaviours (Mono) are added to it. EntityCore comes with a built-in EntityLevel (plain C# class) that manages the experience and the level of the entity. Stat A Stat is a class that derives from ScriptableObject (SO) and represents a statistic in the game. Each statistic has a name (the name given to the SO instance of the created Stat), and we can choose whether to provide it with a maximum and/or minimum value. Additionally, we can define how that statistic grows or is reduced, depending on certain Attributes. StatSet A StatSet is a class derived from ScriptableObject that defines a collection of Stats. Stat sets can be composed by combining other sub-stat sets, enabling hierarchical organization and easy reuse of statistics among different entities or classes. EntityStats EntityStats allows us to configure: the base statistics the flat modifiers the StatToStat modifiers the percentage modifiers We will see what these modifiers are in the section Understanding Stat Modifier Types. The base statistics can be fixed, or instead derive from a class if the entity has one assigned. If we use the fixed ones, we must also provide a StatSet, while if we use those of a class, the class's StatSet will be used. If the entity levels up and we want its statistics to grow with levels, we are forced to use a class, as the fixed statistics are immutable. Class Class derives from SO and represents a game class. Each class has a name, a GrowthFormula that defines how the base Max HP grows with levels, a StatSet, optionally an AttributeSet, and associates each Stat of the provided StatSet with a GrowthFormula that describes how the statistic varies with levels. Similarly, if an AttributeSet is provided, it will be possible to associate a GrowthFormula for each Attribute present in the set, to describe how the attributes vary with levels. EntityClass EntityClass derives from Mono and allows us to assign a Class to our entity. Attribute An Attribute is a class that derives from SO and represents an attribute in the game. Each attribute has a name and, like statistics, can have a maximum and minimum value. AttributeSet An AttributeSet is a class that derives from SO and defines a set of Attributes. EntityAttributes Optionally, we can add the Mono EntityAttributes to our entity if we want to give it attributes. EntityAttributes allows us to specify how many attribute points to provide at each new level. These points can be spent on various attributes to increase their value. For EntityAttributes we can configure: the base attributes the flat modifiers the percentage modifiers Similarly to EntityStats, we can decide whether the base attributes are fixed or if they instead derive from the class associated with EntityClass. Growth Formula To express how Stats, Attributes, Max HP, and the experience required to level up vary at each level, we can use instances of GrowthFormula. This is a class that derives from SO and allows us to define a mathematical function, or a system of functions, that describe how a value changes as levels increase. We will see in more detail how to define a GrowthFormula in the Growth Formulas section. Scaling Formulas Scaling formulas provide a flexible way to define how values such as damage, healing, or other effects are calculated based on one or more attributes or stats. They allow you to combine base values (which can be constant or level-dependent) with contributions from various stats and attributes, each weighted by customizable scaling components. Scaling components Specify how much a particular stat or attribute influences the final value of the scaling formula, enabling complex and dynamic calculations for abilities, equipment, or other game mechanics. This modular approach lets you easily adjust and extend scaling logic to fit your game's needs. Game Events Game events are ScriptableObjects that allow you to implement the Observer pattern in your game. They provide a way to decouple systems by broadcasting notifications when something happens (such as a player jumping, leveling up, or taking damage). Listeners can subscribe to these events and react accordingly, all through inspector-driven workflows. Game events can carry context parameters, making them flexible for a wide range of use cases. Game Event Generators Game Event Generators are ScriptableObjects that let you define custom game events with up to four context parameters. They automate the creation of event and listener classes, making it easy to extend your event system for complex gameplay scenarios. You can specify parameter types and documentation, and generate code and assets directly from the inspector. How is Astra RPG Framework implemented? The package is developed around a Scriptable Objects architecture inspired by the GDC talk of Ryan Hipple. In a nutshell, the main benefits provided by this architecture are: encapsulation: separation of game logic from data. Game logic code shouldn't mix with data. All data is nicely wrapped withing SO instances game designers friendly: game designers can make changes and balancements from the inspector without touching the code greater reusability: most features are ScriptableObjects that can be reused by many components greater testability: being data separated from code, is easier to isolate and fix bugs. Moreover, SO events can be raised with ease at the press of a button from the inspector interface, easing and speeding up debugging even further. Flexibility of Astra RPG Framework Although the package is specifically designed for RPG games or games with progression systems, its flexibility allows it to be used in almost any game. As it allows creating attributes like strength, dexterity, agility, etc., and statistics such as physical attack, magic power, physical defense, etc., in RPG, Roguelike, MMO games, etc., nothing prevents it from being used, for example, to implement a firearm. The attributes could be weight, size, ergonomics, etc., and the statistics recoil, handling, stability, intimidation, etc. Attributes can influence statistics. A heavier weapon could reduce handling but increase stability. A larger weapon could reduce handling but increase intimidation. A more ergonomic weapon could reduce recoil and increase handling. And so on... The weapon's levels, if present, influence the attributes and statistics, progressively improving them. Classes could represent weapon types (assault rifles, snipers, shotguns, etc.), and each class could have its own set of dedicated attributes and statistics. For example, shotguns could have, in addition to the aforementioned ones, the barrel length attribute that influences the pellet spread statistic."
  },
  "MD/limitations.html": {
    "href": "MD/limitations.html",
    "title": "Limitations | Astra RPG Health",
    "summary": "Limitations OnStatChangedEvent is risen only when modifiers are applied, not on level-ups/base stat changes OnAttributeChangedEvent is risen only when modifiers are applied and spendable points are assigned, not on level-ups/base attribute changes Currently, multi-classing is not supported. Each entity can only have one class at a time Stat modifiers are applied in the following order: Flat modifiers Stat-to-stat modifiers Percentage modifiers Stat-to-stat modifiers use the base value and the flat modifiers for the source stat for the calculations. This ensures that the modifiers are applied consistently and predictably, and that circular dependencies can be defined without issues. Attribute modifiers do not have a attribute-to-attribute modifier system. This was a design choice to keep the system simpler. Attribute modifiers are applied in the following order: Flat modifiers Percentage modifiers Only one event for stats changed, attributes changed, and entity spawned can be assigned to entities. However, multiple event listeners can be assigned for the same event type, allowing for multiple responses Custom game event generators support up to four context parameters. To work around this limitation, users can combine multiple pieces of data into a single user-defined class—a technique known as \"parameter packing.\" This approach is extensible through inheritance and helps maintain a simple, user-friendly API by avoiding telescoping parameters."
  },
  "MD/migration-guide.html": {
    "href": "MD/migration-guide.html",
    "title": "Migration Guide | Astra RPG Health",
    "summary": "Migration Guide Migrating from v1.0.0 to v1.1.0 The rebranding of SOAP RPG Framework to Astra RPG Framework involves several changes that need to be addressed when updating existing projects. This guide outlines the necessary steps to ensure a smooth transition. 1. Backup Your Project Before making any changes, it's crucial to back up your project. Whether you are using version control or simply creating a copy of your project folder, having a backup will allow you to revert to the previous state if anything goes wrong during the migration process. 2. Update the Package from the Package Manager Open Unity and navigate to the Package Manager (Window -> Package Manager). In the \"In This Project\" section, locate the SOAP RPG Framework package. Update it to version 1.1.0, which is now listed as Astra RPG Framework. 3. Update Namespaces in Your Code If your project contains scripts that reference the old SOAP RPG Framework namespaces, you'll need to update these references to the new Astra RPG Framework namespaces. For doing this, you can use your IDE's find-and-replace-all functionality (Ctrl + Shift + R in VSCode): Open the find-and-replace dialog in your IDE. Type ElectricDrill.SoapRpgFramework and assert that the \"Match Case\" option is enabled. Inspect the found occurrences to ensure they are correct. Replace all occurrences that makes sense to you with ElectricDrill.AstraRPGFramework. Save all modified files. Return to Unity and recompile the project. If this is not automatic, you can force recompilation with Ctrl + R. If your project compiles correctly, you're done! If you get errors related to duplicate .asmdef files, follow the next steps. 4. Remove duplicate .asmdef files in the package In the hierarchy of your project, navigate to the Packages folder and locate the Astra RPG Framework package. Open the Runtime folder. Ensure that there is only one .asmdef file named com.electricdrill.astra-rpg-framework.Runtime. If you find also a file named com.electricdrill.soap-rpg-framework.Runtime, delete it. Open now the Editor folder of the package. Ensure that there is only one .asmdef file named com.electricdrill.astra-rpg-framework.Editor. If you find also a file named com.electricdrill.soap-rpg-framework.Editor, delete it. Click on the com.electricdrill.astra-rpg-framework.Editor file to select it. In the Inspector window, in the Assembly Definition References section, add the reference to com.electricdrill.astra-rpg-framework.Runtime if it's not already present, and delete any reference to com.electricdrill.soap-rpg-framework.Runtime if present. Click on apply to save the changes. Note Unity sometimes has unpredictable behaviors when updating .asmdef files in and their references. After applying the changes mentioned above, try also to close and reopen Unity to ensure that the changes are correctly applied. If you still encounter issues, fix the new problems and re-start Unity again. At that point, the changes should be correctly applied. 5. Recompile the Project If Unity didn't automatically recompile the project after these changes, you can force recompilation. Your project should now be successfully migrated to Astra RPG Framework v1.1.0. Happy developing! Troubleshooting I re-imported Samples that I already had from v1.0.0 and now I have errors If you used the ScriptableObject based samples of the Utils folder in your project, you can keep using them as they are fully compatible with the new version. In fact, you should not re-import them as that would create duplicates in your project. Warning Do not delete any ScriptableObject based asset that you are using in your project! Delete the duplicates from the newly imported samples instead. This will prevent data loss in your project. Moreover, it was noticed that re-importing samples in a project that was using v1.0.0 of the package, resulted in old namespaces being used in the samples scripts. This is likely a Unity bug as does not happen on a fresh project. If this happens, please rename the old ElectricDrill.SoapRpgFramework namespace in the scripts of the samples to ElectricDrill.AstraRPGFramework manually, analogously to what is described in step #3. Still Need Help? For any issue during the migration, feel free to reach me out by sending me an email at electricdrill.info@gmail.com"
  },
  "MD/package-contents.html": {
    "href": "MD/package-contents.html",
    "title": "Package Contents | Astra RPG Health",
    "summary": "Package Contents The relevant content for you consists of the package samples and the \"utility events\" contained in the package folder (located in /Packages). For more information about the samples, see the Samples documentation. The \"utility events\" (Game Event Generators, source code of the generated events, and instances of the Game Events) have been intentionally placed outside the samples folder because they are used directly in the package's source code. Therefore, it would not be correct to place them in the samples folder, as omitting them during package import would cause the source code to not function correctly. The Game Event Generators are located in the Packages/AstraRPGFramework/Runtime/Events/EventGeneratorInstances folder. Here you will find: GeneralPurposeEventGenerator: defines two game events: EntityCoreGameEvent and IntGameEvent. AttributesEventGenerator: defines AttributeChangedGameEvent StatEventsGenerator: defines StatChangedGameEvent Warning Do not modify these Game Event Generators, as they are an integral part of the package's source code. If you want to add new events, create new Game Event Generators in your Assets and use those to define your custom events. The source code for the events defined within the aforementioned Game Event Generators is located in the Packages/AstraRPGFramework/Runtime/Events/GeneratedEvents folder. The organization follows the rules mentioned in the Adding new events documentation. The instances of the generated Game Events are provided with the samples of the package instead. Such objects are also used by the Sample Scene (always available in the samples folder). If you want to instantiate new Game Events of type EntityCoreGameEvent, IntGameEvent, AttributeChangedGameEvent, or StatChangedGameEvent, feel free to do so."
  },
  "MD/requirements.html": {
    "href": "MD/requirements.html",
    "title": "Requirements | Astra RPG Health",
    "summary": "Requirements Unity 2022.3.50f1 or later"
  },
  "MD/samples.html": {
    "href": "MD/samples.html",
    "title": "Samples | Astra RPG Health",
    "summary": "Samples The samples folder contains 2 sub-folders: utils: contains some utility objects that can be used in your game. examples: contains resources that are used in the sample scene to showcase the package's features Utils The Utils folder contains 2 sub-folders: EventInstances: containing Entity Attribute Changed, Entity Spawned, Entity Stat Changed, and On Player Level Up Game Events. These are instances of the Game Events defined in the package's source code. Player: containing Max Level, Player Hp, Player Max Hp, and Player Level Int and Long variables. These are useful to use Scriptable Object variables in your game, as showcased in the Workflows documentation. Examples There are several objects in this folder. Let's start by the Sample Scene. Here we have two relevant game objects: Heroes and HeroesHUD. These wrappers contain the entity game objects and the GUI elements that are used to display the heroes' stats and attributes respectively. There are three heroes in the Heroes GO: Warrior, Mage, and Rogue. Each hero has its own game object, with the following components: EntityCore EntityClass EntityStats EntityAttributes The objects in the HeroesHUD are not as relevant. Feel free to explore them, but they are not the focus of this documentation as they are just used to display the heroes' stats and attributes in the UI. Along with the Sample Scene, there are a few sprites and UI scripts (in the Sprites and Scripts folders respectively), some prefabs in the Prefabs folder, a few events in the Events folder, and some more relevant content in the Instances -> Classes folder. Here, we have all the instances of the frameworks's scriptable objects for the Sample Scene. For each class we have the following: Attributes growth formulas Stats growth formulas An Int var for the hero's level A Max HP growth formula The class itself All these objects are used in the Sample Scene to showcase the package's features. Using the Sample Scene The scene uses Strength, Intelligence, Dexterity, and Constitution as attributes, and Physical Attack, Magical Attack, Critical Chance, and Defense as stats. Each stat scales with the respective attribute: Physical Attack scales with Strength Magical Attack scales with Intelligence Defense scales with Constitution Critical Chance scales with Dexterity If you now enter play mode in the Sample Scene, you'll see three heroes: the Warrior (left), Mage (center), and Rogue (right), each with their respective HUD displayed above them. You can use the arrow buttons (< and >) to toggle between viewing the heroes' stats and attributes. The Sample Scene is designed to demonstrate how stats and attributes respond to changes made in the inspector. For example, select the Warrior in the hierarchy and change its Level from 1 to 2 using the Entity Core component. You'll observe that the Warrior's Physical Attack increases from 28 to 29, and Defense rises from 26 to 27. Increasing the level also grants the Warrior a spendable attribute point (visible in the EntityAttributes component). If you allocate this point to Strength, the Physical Attack will increase from 29 to 30. If you revert the level back to 1, Physical Attack returns to 28 and the spent attribute point is removed. Next, let's adjust how Physical Attack scales with the Strength attribute. By default, each point of Strength adds 1 point to Physical Attack. Suppose you want each point of Strength to contribute 3 points instead. To do this, locate the Physical Attack stat instance in Examples -> Instances -> Hero -> Stats. Select the Physical Attack stat, then double-click the Physical Attack ASC object in the inspector. This Attribute Scaling Component controls how Physical Attack scales with Strength. You'll notice the scaling value for Strength is set to 1. Change this to 3. Instantly, the Warrior's Physical Attack at level 1 jumps from 28 to 60, since the base value is 12 and the Warrior has 16 points of Strength: 12 + (16 × 3) = 60. If you increase the Warrior's level to 2, Physical Attack becomes 61. Assigning the new attribute point to Strength further increases Physical Attack from 61 to 64. After exiting play mode, inspect the modified objects. You'll see that the Warrior's level is reset to 1, Physical Attack returns to 28, and the Physical Attack ASC (ASC stands for Attribute Scaling Component) scaling for Strength is back to 1. This happens because changes made to ScriptableObjects during play mode are not saved to disk when you exit play mode. This is intentional Unity behavior, not a package bug. Persisting such changes would be risky. For example, if a debuff reduces the scaling of Physical Attack from Strength to zero during play mode and this is saved, you would permanently lose the original scaling—even after restarting without the debuff. ScriptableObjects in this package are intended to define your game's baseline mechanics. Any modifications during play mode are temporary and not meant to be saved. Fine-tuning these values is crucial in RPGs, and once you achieve the desired balance, you want to ensure those values remain intact. You can also explore the other heroes and all their components in the scene. Play around with their levels, stats scalings, attributes and their spendable points, and see how they affect the heroes' stats and attributes in real-time."
  },
  "MD/workflows.html": {
    "href": "MD/workflows.html",
    "title": "Workflows | Astra RPG Health",
    "summary": "Workflows Creating instances of the objects All the scriptable objects provided by the framework can be created through the Unity Editor by either right-clicking in the hierarchy and selecting Create > Astra RPG or navigating to the Assets menu at the top of the window and choosing Create > Astra RPG. Mandatory, re-play, and read-only fields Fields marked with a red asterisk (*) are mandatory and must be filled out to ensure proper functionality of the framework. Fields marked with an orange R are re-play fields. Any changes made to these fields during playtime will require a restart to ensure the changes take effect. Fields marked with a teal RO are read-only fields. The framework manages these fields internally, and they cannot and should not be modified directly by the user. Some utilities Almost every class provided by this package uses events or variables in the form of ScriptableObject. Therefore, let's quickly introduce these concepts so that we are clear about what we are talking about when we encounter them in the following paragraphs. Game events as ScriptableObjects The Scriptable Objects based architecture allows us to implement the Observer pattern through scriptable objects. In the simplest case, with events without context, we can define various game events as GameEvent instances: a class that derives from ScriptableObject. For example, we can create an instance called PlayerJumped that represents the event \"The player has jumped\". This event will notify all listening systems when it occurs. Systems subscribe to this event using the MonoBehaviour GameEventListener. We can assign a GameEvent to this component, and it will handle the subscription and invoke a callback when the event is triggered. The callback is a UnityEvent, so we can select a callback to invoke in response to our event directly from the inspector. For more details, see the Game Events section. Int and Long Vars Another common use of ScriptableObject in the SO based architecture is to define variables. The main advantage of these variables in the form of SO is that they can be easily shared between various objects that may decide to share the same value. A common example is the player's game score. There could be a game manager that adds or removes points from this variable, while the UI HUD uses it to display its value on the screen. This way, we can keep the game manager and UI completely decoupled, passing shared values (like variables) through the inspector. From the code, we can access the values held by these variables using the Value getter and setter: // intVar is an instance of IntVar int value = intVar.Value; // Get the value // Thanks to implicit conversion, we can also use it as an int directly int intValue = intVar; // Implicit conversion to int intVar.Value = 10; // Set the value Int and Long Refs IntRef and LongRef allow choosing whether to use a native value (int or long) or an IntVar/LongVar. As mentioned in the previous paragraph, IntVar and LongVar have the advantage of being shareable between different components/game objects, while native values are more immediate to use and require less setup (no need to instantiate an IntVar/LongVar and assign it in the inspector). Thanks to a custom property drawer, it will be possible, from the inspector, to check a checkbox named Use constant to use a native value instead of a Ref, and vice versa. IntRef and LongRef are widely used in the package's MonoBehaviour. From the code, we can access the values held by these references using the Value getter and setter. It is worth mentioning that when we use the setter, we need to provide a native int or long value. If Use constant is unchecked, this value will be assigned to the Value property of the referenced IntVar or LongVar instance; if Use constant is checked, the assignment only updates the local constant value and does not affect any referenced variable. // intRef is an instance of IntRef int value = intRef.Value; // Get the value // Thanks to implicit conversion, we can also use it as an int directly int intValue = intRef; // Implicit conversion to int intRef.Value = 10; // Set the value // Assigns the value of intVar to intRef.Value using implicit conversion. // Note: This does not change the IntVar reference held by intRef, only its value. intRef.Value = intVar; Game events The package also supports game events with up to 4 context parameters. They are generics, but in Unity, it is not possible to instantiate classes that derive from ScriptableObject if they are generics with unspecified type parameters. To use them, we must explicitly declare classes that derive from the generic GameEvent and fix the type parameters with concrete types. To simplify the definition of new event types, with specific types as context parameters, the package provides GameEventGenerator. These generators, which derive from SO, allow generating the concrete classes of GameEvent. We will see these generators in more detail in the Game Event Generators section. Some game events are already defined and made available by the package (see the Samples page). Growth Formulas Relative path: Growth Formula As already mentioned in Introduction, GrowthFormula allows defining how a certain value varies as levels increase. A GrowthFormula can be instantiated through the hierarchy context menu by going to Astra RPG Framework -> Growth Formula. The package provides a custom property drawer for GrowthFormula. Max level for the values In the inspector of a GrowthFormula, we can pass an IntVar to define up to which level to grow the values. Use constant at level one If the checkbox named Use constant value at level 1 is checked, the respective constant value will be used. Growth expressions The various values of the GrowthFormula are defined by a function where values, the y-axis, are expressed as a function of the levels, the x-axis. Such a function is defined as a composite function. Each segment of the function is represented by a string that specifies a mathematical expression for a range of levels. The string can be defined by using the Unity ExpressionEvaluator syntax. On top of it, the following terms can be used: LVL: the level at each iteration PRV: the previous value of the GrowthFormula (value evaluated at the previous level) SPRV: the second previous value of the GrowthFormula (value evaluated 2 levels ago) PRV[N]: (\uD83C\uDFF7️v1.3.0+) the N-th previous value of the GrowthFormula (value evaluated N levels ago). N must be a valid number with respect to the level range being used. For example, N cannot be 5 if we are evaluating level an expression in the level range 3 --> 10, as PRV[5] at level 3, 4, and 5 will be undefined. AT[N]: (\uD83C\uDFF7️v1.3.0+) the value of the GrowthFormula at level N. N cannot be a value equal or grater than the current level being evaluated. SUM: the sum of the values of the GrowthFormula from level 1 up to the previous level Example of a GrowthFormula Let's see an example of how to define a GrowthFormula for defining the Physical Attack of a warrior class. First of all, let's create a new GrowthFormula instance and name it Warrior Physical Attack GF. In the inspector, it should look like this: The Max Level, a mandatory field, is set with an IntVar assigned by default. We can edit that variable to change the maximum level that will be computed for our growth formula. Warning When modifying the value of a variable referenced in growth formulas, such as Max Level, the growth formulas are not directly updated unless you select them in the inspector. To update all growth formulas simultaneously after changing the maximum level, a command is available in the menu: Tools > Astra RPG Framework > Validate All Growth Formulas. Validation occurs automatically during script compilation, upon entering play mode, and when instantiating a prefab. This is achieved through the OnValidate callback, which ensures that formulas are updated accordingly. The Use constant value at level 1 checkbox lets us decide whether to use a constant value at level 1 or not. If checked, the Constant Value field will be enabled, and we can set a value for it. In this case, we set it to 10. The Add new growth expression button lets us add a growth expression for a certain range of levels of our choice. If we press it, we will see the following: The new section includes two fields: From Level and Growth Expression. From Level: Specifies the starting level at which the corresponding Growth Expression becomes effective. Growth Expression: Defines how the value evolves starting from the specified level. If the Growth Expression overlaps with the Constant At Lvl 1 option, a warning will appear. To resolve this, set the From Level field to 2 or higher, and the warning will disappear. We want to model the Physical Attack of a warrior as follows: Level 1: 10 From level 2 to level 5: +2 per level At level 11: flat +30 (like a bonus due to other game mechanics, such as an awakening) From level 12 and onward: grows by 7% each level To achieve this, set the Constant At Lvl 1 field to 10. For the first growth expression, use PRV + 2 as the formula. PRV, as we saw before, represents the value of the growth formula at the previous level (in this case, 10 at level 1). This formula ensures that the value grows by 2 times the level at each subsequent level. Next we want to press the Add new growth expression button to add the next growth expression for the levels. For the second growth expression, set From Level to 11 and use the formula PRV + 30. This ensures that at level 11, a flat bonus of 30 is added to the previous value. Finally, for the third growth expression, set From Level to 12 and use the formula PRV * 1.07. This ensures that from level 12 onward, the value increases by 7% each level. After adding these growth expressions, the GrowthFormula for the Warrior Physical Attack GF should look like this: With this setup, the GrowthFormula will correctly calculate the Physical Attack values for the warrior class based on the specified rules. Interactive Chart If you hold your mouse for a moment onto the chart, a label will show up, showing the exact value of the growth formula at the pointed level: Retrieving growth values from code To retrieve the values of a GrowthFormula from code, you can use the GetGrowthValue(int level) method. For example, to get the Physical Attack value at level 5, you can do: // warriorPhysicalAttackGF is a reference to the Warrior Physical Attack Growth Formula int physicalAttackLevel5 = warriorPhysicalAttackGF.GetGrowthValue(5); Making a GameObject an entity To make a GameObject an entity, we need to add the MonoBehaviour EntityCore to it. Select your object from the hierarchy and click, in the inspector, on \"Add component\". Then search for and select EntityCore. From the inspector, we can configure several values. Let's analyze them one by one. Level: defines the entity's level. By changing its value, we can assign a different level to the entity directly from the inspector. This can be useful for testing purposes. You'll notice the Use Constant checkbox. If checked, you can pass an IntVar instead of using a constant. Current Total Experience: Represents the total experience possessed by the entity. Warning If you've passed a LongRef for the current total experience, the value contained in this variable should not be modified manually. If Use constant is checked instead, the value is readonly. Max Level: The maximum level the entity can reach Experience Formula: GrowthFormula that describes how the total experience required to reach the next level grows at each level. On Level Up: EntityLeveledUpGameEvent that should be raised when the entity levels up. On Level Down: (\uD83C\uDFF7️v1.2.0+) EntityLeveledDownGameEvent that should be raised when the entity levels down. Spawned Entity Event: EntityCoreGameEvent that should be raised when this entity's Start() method is executed. You may notice that a game event is already assigned to Spawned Entity Event. This is because an instance of that game event has been explicitly assigned directly in the inspector of the EntityCore script. This choice was made since in most cases the same event instance will always be used for entity spawning. This means you don't have to reassign this event every time you create a new entity in Unity. As we'll see later, this default assignment mechanism has been used for other components as well. EntityLevel code APIs It is honorable to mention some code APIs that can be used to interact with the EntityLevel component. EntityLevel exposes a Action<EntityCore, int> OnLevelUp property that can be used to subscribe to level-up events from code. If we want to grant experience to the entity, we can use the AddExp(long amount) method. This method will automatically raise the OnLevelUp event if the entity levels up. Alternatively, it is available also the SetTotalCurrentExp(long totalCurrentExperience) method, which allows setting the total current experience of the entity. This method will also raise the OnLevelUp event if the entity levels up, and the OnLevelDown event if the entity levels down. (\uD83C\uDFF7️v1.2.0+) Similarly, the RemoveExp(long amount) method allows deducting experience from the entity. This method will raise the OnLevelDown event if the entity levels down. If you want to respec an entity, the ResetToLevelOne() method resets the entity's level and experience to level 1. This method will raise the OnLevelDown event if the entity levels down. Clearly, all spent attribute points will be reset as well. Finally, there are the CurrentLevelTotalExperience() and the NextLevelTotalExperience() methods. These methods return the total experience required to reach the current level and the next level, respectively. They are useful, for example, for checking how much experience is needed to level up. Creating Astra RPG Framework assets All the instances of the various assets that derive from ScriptableObjects can be created in the following ways: Context menu: Right click on the hierarchy > Create > Astra RPG Framework Top bar: Assets > Create > Astra RPG Framework Hotkeys: By pressing the respective keyboard shortcut while a folder or an element of the hierarchy is currently selected Note For Mac users the Ctrl key corresponds to the Cmd key. Create attributes Keyboard shortcut: Ctrl + Alt + A Relative path: Attribute Once created a new attribute you can name it as you wish and you'll be able tweak some settings in the inspector. For example lets create a Strength attribute. Create an Attributes folder in your hierarchy, then press A and name the newly created attribute Strength. In the inspector it should look like: By checking Has Max Value, we will set a maximum value for the attribute. By default, there is no maximum value. By checking Has Min Value, we will set a minimum value for the attribute. By default, the minimum value is zero. Repeat the process for also the Constitution, Intelligence, and Dexterity attributes. Create an attribute set Relative path: Attribute Set Now that we have some attributes let's create an AttributeSet named, for example, Hero Attribute Set. In the inspector it should look like this: An attribute set without attributes isn't very useful, so let's add the previously created ones, one at a time. To do this, click on the Add button. Notice that an entry with None (Attribute) appears: To assign an attribute to the entry, we can either drag & drop from the hierarchy or click on the small circle button on the right of the newly appeared entry. This mechanism is the same used for public variables or, more generally, for fields annotated with SerializeField, so it will be familiar to you. Let's add Strength using whichever method you prefer. Repeat the process of adding an attribute to the set for Constitution, Intelligence, and Dexterity as well. If you want to remove an attribute from the set, you can click on the small - button on the right of the attribute you want to remove. Add EntityAttributes to an entity The next step is to assign the attribute set we created to an entity. To do this, let's add the EntityAttributes component to our game object. The inspector will look like this: An entity has base points for attributes, which can be either fixed or derived from a class, a configurable amount of attribute points that can be arbitrarily assigned, and these points are granted at each level-up, along with flat and percentage modifiers for the attributes. Except for the modifiers, which can only be assigned via code, all other values can be configured from the inspector. Attr Points Per Level defines how many arbitrarily spendable attribute points are provided at each level-up. They are assigned starting from level 2 on. Attribute Points Tracker allows monitoring and assigning spendable points. Available Points defines how many unspent points are still available. If you change the level of the entity you'll see that available points change accordingly. And as you spend them, Available Points will decrease. Moreover, there is a checkbox labeled Use Class Base Attributes. For now, let's leave it unchecked since we haven't added a class yet. However, in this case, we need to manually assign an attribute set. Therefore, let's set the Attribute Set field found under Fixed Base Attributes with the Hero Attribute Set. By doing this, we now have access to additional fields in the inspector: We can assign values to the attributes of Fixed Base Attributes as we see fit. Understanding Attribute Modifier Types The framework provides two distinct types of attribute modifiers that work together with spent attribute points to determine final attribute values. Understanding how each type works is essential for creating predictable character progression and balanced gameplay mechanics. Note General considerations for attribute modifiers When adding modifiers through code, the OnAttributeChanged event will automatically be raised if the final value changes If cache is being used: when adding modifiers through code, the attribute cache will automatically be invalidated to ensure the correct value is returned on the next access Spent Attribute Points Before diving into modifiers, it's important to understand that spent attribute points form the foundation of the attribute calculation system. These points are allocated by players during character progression and are applied immediately after the base value. Characteristics: Player-controlled allocation of points earned through leveling Applied directly after base values in the calculation order Permanent increases (until points are redistributed) Each point provides a 1:1 increase to the attribute Code example: // Spend 3 points on Strength entityAttributes.SpendOn(strengthAttribute, 3); // Check available points before spending int availablePoints = entityAttributes.AvailableAvailableAttributePoints; if (availablePoints >= 2) { entityAttributes.SpendOn(constitutionAttribute, 2); } Flat Modifiers Flat modifiers add or subtract a fixed amount to an attribute's value. They are applied after base values and spent points but before percentage modifiers. Use cases: Equipment bonuses (e.g., +3 Strength from gauntlets) Temporary buffs (e.g., +5 Constitution from a fortitude potion) Race or class bonuses (e.g., Dwarves get +2 Constitution) Status effects that provide fixed bonuses or penalties Environmental effects (e.g., library affecting Intelligence) Code example: // Add a flat +4 bonus to Strength entityAttributes.AddFlatModifier(strengthAttribute, 4); // Add a flat -2 penalty to Dexterity (negative values work too) entityAttributes.AddFlatModifier(dexterityAttribute, -2); Calculation example: Base Strength: 12 Spent points: +3 Flat modifier: +4 Result after flat modifiers: 12 + 3 + 4 = 19 Percentage Modifiers Percentage modifiers apply a multiplicative increase or decrease to the current attribute value. They are the most powerful type of modifier and are applied last in the calculation chain, after all other values have been calculated. Use cases: Powerful equipment bonuses (e.g., +20% to all attributes) Character traits or talents (e.g., \"Natural Athlete: +15% Strength and Dexterity\") Temporary powerful buffs or curses Class features Magical enchantments or artifacts Code example: // Add a 20% increase to Strength entityAttributes.AddPercentageModifier(strengthAttribute, 20); // Add a 10% decrease to Intelligence (negative percentage) entityAttributes.AddPercentageModifier(intelligenceAttribute, -10) Calculation example: Previous value: 19 (from previous steps) Percentage modifier: +20% = 19 × 0.20 = 3.8 Final result: 19 + 3.8 = 22.8 (rounded to 23 for integer attributes) Important notes: Multiple percentage modifiers are additive before being applied (e.g., +20% and +10% = +30% total) The percentage is calculated based on the value after base, spent points, and flat modifiers Percentage modifiers can be negative to create penalties Complete Calculation Example Let's see a complete example showing the full attribute calculation process: Initial setup: Base Intelligence: 14 Points spent on Intelligence: 4 Equipment flat bonus: +2 (from a circlet) Trait percentage bonus: +25% (from \"Scholar\" trait) Step-by-step calculation: Start with base: 14 Add spent points: 14 + 4 = 18 Apply flat modifiers: 18 + 2 = 20 Apply percentage modifiers: 20 + (20 × 0.25) = 20 + 5 = 25 Final Intelligence value: 25 Comparison with Stat Modifiers Unlike stats, attributes have a simpler modifier system: Attributes have: Base values Spent attribute points (player-controlled) Flat modifiers Percentage modifiers Stats additionally have: Stat-to-stat modifiers (attributes don't have attribute-to-attribute modifiers) More complex scaling relationships Stats can scale upon attributes This simplicity makes attributes more predictable and easier for players to understand, while stats can have more complex interactions. Keeping them simple helps maintain clarity in gameplay Retrieving Attribute Values from code Due to the relevance of retrieving attribute values from code, the methods to do so are worth mentioning here. To retrieve the final value of an attribute, you can use the Get method: // strengthAttribute is a reference to the Strength Attribute int strength = entityAttributes.Get(strengthAttribute); To retrieve the base value of an attribute, you can use the GetBase method: // strengthAttribute is a reference to the Strength Attribute int baseStrength = entityAttributes.GetBase(strengthAttribute); Spending attribute points If the entity's Attr Points Per Level is greater than zero and the level is greater than 1, we can spend attribute points on the attributes. To do this, we can use the SpendOn method: // strengthAttribute is a reference to the Strength Attribute entityAttributes.SpendOn(strengthAttribute, 2); This will spend 2 points on the Strength attribute, increasing its value by 2. If there are not enough available points, a Debug.LogError will be raised. Note Debug.LogError messages are shown only in development builds. If you run a production build, you won't see them. This is useful to avoid cluttering the console with error messages that are not relevant in production. Create stats Keyboard shortcut: Ctrl + Alt + S Relative path: Stat As with attributes, you can create stats as you wish and assign them the names you prefer. Let's create the Physical Attack stat together. Create a new Stats folder, select it and press S. Name it Physical Attack. In the inspector, it should look like this: As with attributes, you can assign both a maximum and a minimum value to a stat. Repeat the process for the Magical Power, Defense, and Critical Chance stats. Unlike attributes, however, stats include Attributes Scaling. Create an Attribute Scaling Component for Stats Relative path: Scaling -> Attribute Scaling Component Let's create a new Attribute Scaling Component to use with the strength stat we created earlier. Create a new folder named, for example, Attribute Scalings for Stats, and inside it, create an attribute scaling component called Physical Attack Strength Scaling. Assign the previously created Hero Attribute Set to the Set field. You will see the attributes of the set appear. Here, you can assign scaling values using double. For example, set the scaling of Strength to 1.0. This component defines a 100% scaling on the value of Strength. Now, assign this scaling component to the Physical Attack stat to ensure it scales with the Strength attribute. Create a stat set Relative path: Stat Set Now that we have some stats, let's create a StatSet named, for example, Hero Stat Set. A stat set without stats isn't very useful, so let's add the previously created ones, one at a time. To do this, click on the Add button. Notice that an entry with None (Stat) appears. To assign a stat to the entry, we can either drag & drop from the hierarchy or click on the small circle button on the right of the newly appeared entry. This mechanism is the same used for public variables or, more generally, for fields annotated with SerializeField, so it will be familiar to you. Let's add Physical Attack using whichever method you prefer. Repeat the process of adding a stat to the set for Magical Power, Defense, and Critical Chance as well. The stat set should look like: If you want to remove a stat from the set, you can click on the small - button on the right of the stat you want to remove. Modular stat sets Stat sets can include other stat sets, allowing for modular and reusable configurations. This is particularly useful if we have various kind of entities that share some stats but not all of them. For example, let's consider three entities: a deer, a ballista turret, and our hero character. The deer can take damage, move around, and cannot attack. The turret instead can take damage, deal damage, but cannot move. The hero can do all three things. A first approach could be to create three distinct stat sets for each entity, but this would lead to a lot of redundancy since many stats would be repeated across the three sets. What if we decide to add a new stat that all three entities should have? We would have to remember to add it to all three sets, which is error-prone and inefficient. Alternatively, we could use a single all-embracing stat set that includes all the stats needed by all entities. However, this would lead to unnecessary complexity for entities that don't need all those stats, making it harder to manage and understand. A better approach is to create modular stat sets that can be combined as needed. We can create three stat sets: Damageable Stat Set: includes stats like Armor, Magical Defense, Dmg Reduction, and so on Damage Dealer Stat Set: includes stats like Physical Attack, Magical Power, Critical Chance, and so on Movable Stat Set: includes stats like Movement Speed, Jump Height, etc. Then, we can create three additional stat sets for our entities: Prey Stat Set for the deer, which includes only the Damageable Stat Set and the Movable Stat Set Turret Stat Set for the ballista turret, which includes only the Damageable Stat Set and the Damage Dealer Stat Set Hero Stat Set for our hero character, which includes all three stat sets: Damageable Stat Set, Damage Dealer Stat Set, and Movable Stat Set This modular approach allows us to reuse stat configurations across different entities, reducing redundancy and making it easier to manage and update stats. Add EntityStats to an Entity The next step is to assign the stat set we created to an entity. To do this, let's add the EntityStats component to our game object. The inspector will look like this: An entity has base stats that can be either fixed or derived from a class. Additionally, stats can be modified through flat modifiers, stat-to-stat modifiers, and percentage modifiers. Use Class Base Stats checkbox determines whether the base stats should come from the entity's class (if one is available) or from fixed values defined in the inspector. For now, let's leave it unchecked since we haven't added a class yet. With Use Class Base Stats unchecked, we need to manually assign a stat set. Set the Stat Set field under Fixed Base Stats with our Hero Stat Set. This will reveal additional fields in the inspector where we can set the base values for each stat: On Stat Changed event gets raised whenever any stat value changes due to modifiers. You can use this to update UI elements or trigger other game logic. Use Cache enables caching of final stat values. This is useful for performance when you have many entities or complex stat calculations. Understanding Stat Modifier Types The framework provides three distinct types of stat modifiers, each serving different purposes and applied in a specific order during final value calculation. Understanding how each type works is crucial for creating balanced and predictable stat systems. Note General considerations for stat modifiers If cache is being used: when adding modifiers through code, the attribute cache will automatically be invalidated to ensure the correct value is returned on the next access When adding modifiers through code, the OnStatChanged event will automatically be raised if the final value changes. Flat Modifiers Flat modifiers add or subtract a fixed amount to a stat's value. They are the simplest type of modifier and are applied directly after the base value. Use cases: Equipment bonuses (e.g., +5 Physical Attack from a sword) Temporary buffs (e.g., +10 Defense from a shield spell) Status effects that provide fixed bonuses or penalties Code example: // Add a flat +15 bonus to Physical Attack entityStats.AddFlatModifier(physicalAttackStat, 15); // Add a flat -5 penalty to Defense (negative values work too) entityStats.AddFlatModifier(defenseStat, -5); Calculation example: Base Physical Attack: 50 Flat modifier: +15 Result after flat modifiers: 50 + 15 = 65 Stat-to-Stat Modifiers Stat-to-stat modifiers allow one stat to contribute a percentage of its value to another stat. This creates interesting dependencies between different stats and allows for more complex character builds. These modifiers are applied right after the flat modifiers. Use cases: Cross-stat synergies (e.g., 25% of Armor is added to Physical Attack). Warning When using stat-to-stat modifiers, only the base value and flat modifiers of the source stat are used in the calculation. Stat-to-stat modifiers and percentage modifiers applied to the source stat are ignored. This ensures predictable and non-circular calculations. Code example: // 25% of armor is added to physical attack entityStats.AddStatToStatModifer(physicalAttackStat, armorAttribute, 25); // Negative modifier: -10% of armor is subtracted from physical attack entityStats.AddStatToStatModifer(physicalAttackStat, armorAttribute, -10); Calculation example: Base Physical Attack: 50 Flat modifier: +15 (from previous step) Current value: 65 Armor value: 40 Stat-to-stat modifier: 50% of Armor = 40 × 0.5 = 20 Result after stat-to-stat modifiers: 65 + 20 = 85 Important notes: The source stat's base value + its flat modifiers is used for calculation Multiple stat-to-stat modifiers from different sources are additive, and order of calculation is commutative You can have the same source stat contribute to multiple target stats Circular dependencies can be defined, as the base values + flat modifiers are used for calculations Percentage Modifiers Percentage modifiers apply a multiplicative increase or decrease to the current stat value. They are applied last in the calculation chain. Because of this, they can have a significant impact on the final value. Use cases: Powerful equipment bonuses (e.g., +25% damage increase) Character traits or talents (e.g., \"Warrior's Might: +20% Physical Attack\") Temporary powerful buffs or debuffs Code example: // Add a 25% increase to Physical Attack entityStats.AddPercentageModifier(physicalAttack, 25); // Add a 15% decrease to movement speed (negative percentage) entityStats.AddPercentageModifier(movementSpeed, -15); Calculation example: Previous value: 85 (from previous steps) Percentage modifier: +25% = 85 × 0.25 = 21.25 Final result: 85 + 21.25 = 106.25 (rounded to 106 for integer stats) Important notes: Multiple percentage modifiers are additive before being applied (e.g., +25% and +15% = +40% total) The percentage is calculated based on the value after flat and stat-to-stat modifiers Percentage modifiers can be negative to create penalties Complete Calculation Example Let's see a complete example with all three modifier types: Initial setup: Base Physical Attack: 100 Armor value: 60 (base + flat modifiers) Applied modifiers: Flat modifier: +20 (from weapon) Stat-to-stat modifier: 75% of Armor = 60 × 0.75 = 45 Percentage modifier: +30% (from various sources) Step-by-step calculation: Start with base: 100 Apply flat modifiers: 100 + 20 = 120 Apply stat-to-stat modifiers: 120 + 45 = 165 Apply percentage modifiers: 165 + (165 × 0.30) = 165 + 49.5 = 214.5 → 214 Final Physical Attack value: 214 Note The framework does not provide a built-in tool for removing applied modifiers. It is up to you to define your own abstraction for buffs, debuffs, or other temporary effects that add and remove modifiers as needed. In the future, the Astra RPG Modifiers extension for this framework will be released, which will include such abstractions thought to integrate seamlessly with the existing systems. Check the status of the extension for more details at https://electricdrill.github.io/ Retrieving Stat Values from code Due to the relevance of retrieving stat values from code, the methods to do so are worth mentioning here. To retrieve the final value of a stat, you can use the Get method: // phyAtkStat is a reference to the Physical Attack Stat int physicalAttack = entityStats.Get(phyAtkStat); To retrieve the base value of a stat, you can use the GetBase method: // phyAtkStat is a reference to the Physical Attack Stat int basePhysicalAttack = entityStats.GetBase(phyAtkStat); Create a class Relative path: Class Let's create an instance of Class called Warrior. It should appear like this: The only mandatory field is Stat Set. If we don't make use of attributes and Max HP, we can leave the Attribute Set and Max HP Growth Formula fields empty. In our case, let's assign our Hero Stat Set to Stat Set and Hero Attribute Set to Attribute Set. This way, the Warrior will have access to all stats and attributes from the assigned Stat Set and Attribute Set. As we fill these two fields, we'll see that the Stat Growth Formulas and Attribute Growth Formulas sections will automatically populate with the stats and attributes from the assigned Stat Set and Attribute Set. Let's proceed to create all the growth formulas for the warrior's stats and attributes. Follow the steps outlined in the Growth Formulas section to create the growth formulas for the warrior's stats and attributes. Once all growth formulas are assigned, the Warrior should look like this: Max HP Growth Formula allows specifying how the Max HP value grows as levels change. In our example, we'll leave it empty. The presence of this field for hit points might be surprising since this module of the framework isn't focused on health management. Indeed, damage and health are managed by the Astra RPG Health module, which will be released in the coming months. However, this field is positioned here since the scaling of base max hp still depends on the class. Keeping the hierarchy clean By now you should have a lot of assets in your hierarchy. To keep it clean, you can create a folder named Classes and move the Warrior class inside it. You can do the same for the Attributes and Stats growth formulas inside the Warrior folder. This way, you can keep the hierarchy organized and easily find the assets. Similarly, the Hero Stat Set and Hero Attribute Set could be placed in a Hero folder, that is common to all the classes. This way, you can have a single set of stats and attributes for all the classes that will be created in the future. This is how your hierarchy could look like: Obviously this is just a possible organization of the assets. Feel free to organize it as you prefer. Add EntityClass to an entity To assign a class to an entity, we need to add the EntityClass component to it. The inspector will look like this: All we have to do now is just assign the Warrior class we created earlier to the Class field. Switching to class-based attributes and stats We can now check the Use Class Base Attributes and Use Class Base Stats checkboxes. By doing this, the entity will use the base attributes and stats defined by the class. The Fixed Base Attributes and Fixed Base Stats fields will be disabled, and the values will be automatically retrieved from the class growth formulas. Retrieving class-based values from code With a class we can access: attributes values: GetAttributeAt(Attribute attribute, int level) stats values: GetStatAt(Stat stat, int level) Max HP values: GetMaxHpAt(int level) For example: // hero is a reference to the EntityCore component of the hero EntityClass warriorClass = hero.GetComponent<EntityClass>(); // hero.Level is of EntityLevel type, but it is implicitly be converted to an int int level = hero.Level; int strengthAtLevel5 = warriorClass.GetAttributeAt(strengthAttribute, level); int physicalAttackAtLevel5 = warriorClass.GetStatAt(phyAtkStat, level); int maxHpAtLevel5 = warriorClass.GetMaxHpAt(level); Create Scaling Formulas Keyboard shortcut: Alt + Shift + S Relative path: Scaling -> Scaling Formula We already saw how to create an Attribute Scaling Component for stats. On top of such usage, scaling components, and more in general scaling formulas, can be used for much more situations. For example, they can be used to define the damage of an ability, to define the bonus granted by a piece of equipment, or to define the damage of a weapon. In general, they can be used to define any kind of scaling that can be expressed as a function of one or more variables. For example, let's create a Scaling Formula called Mighty Blow SF. It should look like this in the inspector: Base Value determines the starting point for the scaling formula. It can either be a fixed constant value or a value that scales with levels (e.g., the level of the Mighty Blow skill). If the latter is chosen, a Growth Formula must be provided to define how the base value changes as levels increase. This scaling formula will be used to define the damage of a skill called Mighty Blow. The scaling formula will be defined as follows: Base damage: 10 at lvl 1, 25 at level 2, 60 at lvl 3 Damage scaling: 1.5 * Physical Attack + 0.5 * Constitution Since we want a base value that varies as level grows, let's check the Use a scaling base value checkbox and create a Growth Formula named Mighty Blow Base Dmg GF. The Mighty Blow Base Damage GF should look like this: Notice that a new Skill Max Lvl has been created and assigned to Max Level. This is necessary as the skill max level is not related to the max level of our hero. We can now assign this growth formula to the Base Value field of the Mighty Blow SF scaling formula. Under Entity Scalings we have Self Scaling Components and Target Scaling Components. The former are used to define the scaling of the entity itself, while the latter are used to define the scaling of the target of the ability. In our case, we will only use Self Scaling Components, so we can leave Target Scaling Components empty. We can now proceed to create the scaling components for the Physical Attack stat and the Constitution attribute. Let's create a new Stat Scaling Component called Mighty Blow Physical Attack Scaling. Assign the Hero Stat Set to it and set the scaling of the Physical Attack stat to 1.5. The scaling component should look like this: Next, we will create a similar Attribute Scaling Component for the Constitution attribute called Mighty Blow Constitution Scaling. Assign the Hero Attribute Set to it and set the scaling of the Constitution to 0.5. The scaling component should look like this: Finally, let's press on the + of Self Scaling Components and assign the two scaling components we just created. The Mighty Blow SF should look like this: Using scaling formulas in code First of all, ScalingFormulas expose two code-only properties: List<ScalingComponent> TmpSelfScalingComponents and List<ScalingComponent> TmpTargetScalingComponents. These properties can be used to add scaling components to the scaling formula at runtime. This is useful when you want to dynamically change the scaling components based on certain conditions or game states, without changing the original serialized scaling formula asset. For example, the character could get a temporary buff that makes the, let's say, Mighty Blow skill scale also with the Intelligence attribute. In this case, we can add a Attribute Scaling Component for the Intelligence attribute to the TmpSelfScalingComponents list of the Mighty Blow SF scaling formula. If the buff wears off, we can remove the scaling component from the TmpSelfScalingComponents list. There is also a method for resetting all the temporary scaling components: ResetTmpScalings(). This method can be useful, for example, when the player completes a room and advances to the next stage or area of the game, and you want to clear all temporary buffs the character received during that stage. Moreover, there are four more methods that are worth mentioning: long CalculateValue(EntityCore self): Calculates the value of the scaling formula by summing the value returned by each self scaling component (calculated on the entity itself values), there must not be any target scaling components. long CalculateValue(EntityCore self, int level): If the scaling formula has a base value that varies with levels, this method calculates the value of the scaling formula for the entity itself, and adds the base value at a specific level. Again, there must not be any target scaling components. long CalculateValue(EntityCore self, EntityCore target): Calculates the value of the scaling formula by summing the value returned by each self scaling component (calculated on the entity itself values) and each target scaling component (calculated on the target entity values). long CalculateValue(EntityCore self, EntityCore target, int level): Calculates the value of the scaling formula by summing the value returned by each self scaling component (calculated on the entity itself values) and each target scaling component (calculated on the target entity values), and adds the base value at a specific level. Game Events Relative path: Events -> Game Event Relative path for custom game events: Events -> Generated -> *CustomEventName* At the beginning of this page we briefly mentioned the concept of game events as scriptable objects, and we have introduced the generic GameEvent. Such event is great for notifying actions that happen in the game, but it has limited flexibility as it is not carrying along any context information. For example, if we want to notify that a character has leveled up, we might want to pass along the entity that leveled up and the new level reached. In other cases it could be useful to pass along with the event a reference to the entity that triggered the event, so we would like to be able to pass a reference of type EntityCore as context parameter. And so on. The framework comes along with some pre-defined game events: IntGameEvent: an event that carries along an int as context parameter EntityCoreGameEvent: an event that carries along an EntityCore as context parameter EntityLeveledUpGameEvent: an event that carries along an EntityCore and an int as context parameters, where the EntityCore is the entity that leveled up and the int is the new level reached StatChangedGameEvent: an event that carries along a StatChangeInfo context parameter, which contains: A reference to the EntityStats component of the entity that has changed The Stat that has changed The previous value of the stat The new value of the stat AttributeChangedGameEvent: an event that carries along an AttributeChangeInfo context parameter, which contains: A reference to the EntityAttributes component of the entity that has changed The Attribute that has changed The previous value of the attribute The new value of the attribute Along with the game events, the frameworks provides the *GameEventListener counterparts, which are components that can be attached to a game object to listen for the events and execute a method when the event is raised. For example, IntGameEventListener listens for a specific IntGameEvent and executes a method that takes an int as parameter when the event is raised. Let's suppose we need a game event for notifying, each time the player dies, how many times the player has died so far. In the inspector, create a new IntGameEvent called PlayerDied. It should look like this: There are no fields to fill in the inspector. The integer to be passed as context parameter will be passed in the code that is responsible for raising the event. The method to raise the event is Raise(int value), which will raise the event and pass along the integer as context parameter. Therefore in a dedicated script you can call it like this: public void OnPlayerDeath() { playerDeathCount++; // Assuming playerDiedEvent is a reference to the PlayerDied event playerDiedEvent.Raise(playerDeathCount); } Now let's create a listener for this event. Let's say that we want to show a message in the console when the event is raised. To do this, create a new game object in the hierarchy and add a script that defines a public method for logging an event, that takes an int as input parameter. It should be like: public void LogPlayerDeath(int deathCount) { Debug.Log($\"Player has died {deathCount} times.\"); } Now add the IntGameEventListener component to the listener game object and, in the inspector, assign the PlayerDied event to the Event field. Now drag the Logger script created before into the Response's object selector. You should be able now to select the LogPlayerDeath method from the dropdown menu. The result should look like this: This is a powerful mechanism that decouples the event producers from the event consumers, allowing for a more modular and maintainable codebase. And most of the setup is inspector-based. You just need to define the raising and the listening methods from code. Game Event Generators Relative path: Events -> Game Event Generator Warning Game event generators are an experimental feature and may change in future releases. To avoid potential issues, it is recommended to back up or version control your project before renaming or moving the generated events to different folders. Sometimes the pre-defined game events are not enough to cover all the use cases. In this case, you can create a custom game event generator. A game event generator is a scriptable object that lets you define a custom game events with up to four context parameters. You can choose the type of each parameter. Parameters can either be primitive types (like int, float, string, etc.) or more complex types (like EntityCore, Stat, StatChangeInfo, ..., or your own data types). Game Event Generator setup Let's create a custom game event generator to manage all the events related to the experience and leveling up of entities. Rename the newly created events generator EntityLevelingEvents. In the inspector, it should look like this: With Menu Base Path we can change the path of the context menu where the generated events will be available for creation. By default, it is set to Astra RPG Core -> Events -> Generated, but we can change it to Astra RPG Core -> Events/Generated/Experience for the sake of organization. With Base Save Location we can change the path where the source code files for the generated events will be saved. By default it is set to Assets, but for this example let's set it to Assets/Events. Adding new events Now let's create an event that will be raised when an entity grants experience to another entity. To do this, click on the Add new event button and fill in the fields as follows: Event Name: EntityGrantedExp Documentation: an entity granted experience to another entity Parameters: press the + button and add the following three parameters: Parameter Type to Mono Script, Mono Script type to EntityCore (drag it from the AstraRpgFramework folder located in the Packages folder) Parameter Type to Mono Script, Mono Script type to EntityCore (drag it from the AstraRpgFramework folder located in the Packages folder) Parameter Type to Native, Native type to long The first parameter represents the entity that granted the experience, the second parameter represents the entity that received the experience, and the third parameter represents the amount of experience granted. Now let's press the Generate Game Events button to create the new event. We can now navigate to Assets/Events/GeneratedEvents/EntityLevelingEvents to find the following two folders: GameEventListeners: contains the source code for all the game event listeners generated by our EntityLevelingEvents game event generator. GameEvents: contains the source code for all the game events generated by our EntityLevelingEvents game event generator. Inside both folders, you'll find a subfolder named 3. The Game Event Generators organize the generated events in subfolders based on the number of parameters they have. In this case, we have a game event with three parameters, so it is placed in the 3 subfolder. However, more interesting is the fact that if we now use the context menu and navigate to Astra RPG Core -> Events -> Generated -> Experience, we can find the EntityGrantedExp event. From here, you can follow the same steps as for the pre-defined game events to create a listener for this event, and to wire it up to the appropriate game logic. If you need to create more experience related events, you can repeat the process of adding new events to the EntityLevelingEvents game event generator. After having generated the source code for the game events, you can also click on the Remove Event button under each Game Event to remove it from the generator and delete the generated source code files. It might be necessary to refresh (right click on an asset folder and select Refresh) the asset folder containing the generated events to see the changes reflected in the Unity editor. Warning Pay attention that renaming or moving the generated events to different folders will cause the game event generator to lose track of them. If you change the Base Save Location and then re-generate the events, the game event generator will first delete the old files and then create new source code files in the new location. This means that any references to the old files will be lost, so you will need to reassign them in the inspector or in the code. This can be highly disruptive if you have many references to the old files, so it is recommended to back up or version control your project before renaming or moving the generated events to different folders. To safely move files you should move them from the Unity editor and then update the Base Save Location field in the game event generator to match the new location of the generated events. This way, the game event generator will be able to find the generated events in the new location and will not attempt to delete/recreate them. Same applies if you rename the generated game event type scripts. To rename them, rename their C# scripts first, and then, and then update the Event Name field in the game event generator to match the new name."
  },
  "api/ElectricDrill.AstraRpgHealth.Config.AstraRpgHealthConfig.html": {
    "href": "api/ElectricDrill.AstraRpgHealth.Config.AstraRpgHealthConfig.html",
    "title": "Class AstraRpgHealthConfig | Astra RPG Health",
    "summary": "Class AstraRpgHealthConfig Namespace ElectricDrill.AstraRpgHealth.Config Assembly com.electricdrill.astra-rpg-health.Runtime.dll public class AstraRpgHealthConfig : ScriptableObject, IAstraRpgHealthConfig Inheritance object Object ScriptableObject AstraRpgHealthConfig Implements IAstraRpgHealthConfig Fields damageSourceModifications public SerializableDictionary<DamageSource, Stat> damageSourceModifications Field Value SerializableDictionary<DamageSource, Stat> damageTypeModifications public SerializableDictionary<DamageType, Stat> damageTypeModifications Field Value SerializableDictionary<DamageType, Stat> Properties DamageSourceModifications public SerializableDictionary<DamageSource, Stat> DamageSourceModifications { get; set; } Property Value SerializableDictionary<DamageSource, Stat> DamageTypeModifications public SerializableDictionary<DamageType, Stat> DamageTypeModifications { get; set; } Property Value SerializableDictionary<DamageType, Stat> DefaultDamageCalculationCalculationStrategy public DamageCalculationStrategy DefaultDamageCalculationCalculationStrategy { get; set; } Property Value DamageCalculationStrategy DefaultOnDeathStrategy public OnDeathStrategy DefaultOnDeathStrategy { get; set; } Property Value OnDeathStrategy DefaultOnResurrectionStrategy public OnResurrectionStrategy DefaultOnResurrectionStrategy { get; set; } Property Value OnResurrectionStrategy DefaultResurrectionSource public HealSource DefaultResurrectionSource { get; set; } Property Value HealSource GenericDamageModificationStat public Stat GenericDamageModificationStat { get; set; } Property Value Stat HealAmountModifierStat public Stat HealAmountModifierStat { get; set; } Property Value Stat HealthAttributesScaling public AttributesScalingComponent HealthAttributesScaling { get; set; } Property Value AttributesScalingComponent LifestealConfig public LifestealConfig LifestealConfig { get; set; } Property Value LifestealConfig ManualHealthRegenerationStat public Stat ManualHealthRegenerationStat { get; set; } Property Value Stat PassiveHealthRegenerationInterval public float PassiveHealthRegenerationInterval { get; set; } Property Value float PassiveHealthRegenerationSource public HealSource PassiveHealthRegenerationSource { get; set; } Property Value HealSource PassiveHealthRegenerationStat public Stat PassiveHealthRegenerationStat { get; set; } Property Value Stat"
  },
  "api/ElectricDrill.AstraRpgHealth.Config.AstraRpgHealthConfigProvider.html": {
    "href": "api/ElectricDrill.AstraRpgHealth.Config.AstraRpgHealthConfigProvider.html",
    "title": "Class AstraRpgHealthConfigProvider | Astra RPG Health",
    "summary": "Class AstraRpgHealthConfigProvider Namespace ElectricDrill.AstraRpgHealth.Config Assembly com.electricdrill.astra-rpg-health.Runtime.dll public static class AstraRpgHealthConfigProvider Inheritance object AstraRpgHealthConfigProvider Properties Instance public static IAstraRpgHealthConfig Instance { get; set; } Property Value IAstraRpgHealthConfig Methods Reset() public static void Reset() WarmUp() public static void WarmUp()"
  },
  "api/ElectricDrill.AstraRpgHealth.Config.AstraRpgHealthGlobalSettings.html": {
    "href": "api/ElectricDrill.AstraRpgHealth.Config.AstraRpgHealthGlobalSettings.html",
    "title": "Class AstraRpgHealthGlobalSettings | Astra RPG Health",
    "summary": "Class AstraRpgHealthGlobalSettings Namespace ElectricDrill.AstraRpgHealth.Config Assembly com.electricdrill.astra-rpg-health.Runtime.dll public class AstraRpgHealthGlobalSettings : ScriptableObject Inheritance object Object ScriptableObject AstraRpgHealthGlobalSettings Properties ActiveConfig public AstraRpgHealthConfig ActiveConfig { get; set; } Property Value AstraRpgHealthConfig"
  },
  "api/ElectricDrill.AstraRpgHealth.Config.IAstraRpgHealthConfig.html": {
    "href": "api/ElectricDrill.AstraRpgHealth.Config.IAstraRpgHealthConfig.html",
    "title": "Interface IAstraRpgHealthConfig | Astra RPG Health",
    "summary": "Interface IAstraRpgHealthConfig Namespace ElectricDrill.AstraRpgHealth.Config Assembly com.electricdrill.astra-rpg-health.Runtime.dll Interface for health system configuration. This allows for dependency injection and easier testing. public interface IAstraRpgHealthConfig Properties DamageSourceModifications SerializableDictionary<DamageSource, Stat> DamageSourceModifications { get; set; } Property Value SerializableDictionary<DamageSource, Stat> DamageTypeModifications SerializableDictionary<DamageType, Stat> DamageTypeModifications { get; set; } Property Value SerializableDictionary<DamageType, Stat> DefaultDamageCalculationCalculationStrategy DamageCalculationStrategy DefaultDamageCalculationCalculationStrategy { get; set; } Property Value DamageCalculationStrategy DefaultOnDeathStrategy OnDeathStrategy DefaultOnDeathStrategy { get; set; } Property Value OnDeathStrategy DefaultOnResurrectionStrategy OnResurrectionStrategy DefaultOnResurrectionStrategy { get; set; } Property Value OnResurrectionStrategy DefaultResurrectionSource HealSource DefaultResurrectionSource { get; set; } Property Value HealSource GenericDamageModificationStat Stat GenericDamageModificationStat { get; set; } Property Value Stat HealAmountModifierStat Stat HealAmountModifierStat { get; set; } Property Value Stat HealthAttributesScaling AttributesScalingComponent HealthAttributesScaling { get; set; } Property Value AttributesScalingComponent LifestealConfig LifestealConfig LifestealConfig { get; set; } Property Value LifestealConfig ManualHealthRegenerationStat Stat ManualHealthRegenerationStat { get; set; } Property Value Stat PassiveHealthRegenerationInterval float PassiveHealthRegenerationInterval { get; set; } Property Value float PassiveHealthRegenerationSource HealSource PassiveHealthRegenerationSource { get; set; } Property Value HealSource PassiveHealthRegenerationStat Stat PassiveHealthRegenerationStat { get; set; } Property Value Stat"
  },
  "api/ElectricDrill.AstraRpgHealth.Config.html": {
    "href": "api/ElectricDrill.AstraRpgHealth.Config.html",
    "title": "Namespace ElectricDrill.AstraRpgHealth.Config | Astra RPG Health",
    "summary": "Namespace ElectricDrill.AstraRpgHealth.Config Classes AstraRpgHealthConfig AstraRpgHealthConfigProvider AstraRpgHealthGlobalSettings Interfaces IAstraRpgHealthConfig Interface for health system configuration. This allows for dependency injection and easier testing."
  },
  "api/ElectricDrill.AstraRpgHealth.Damage.CalculationPipeline.ApplyBarrierStep.html": {
    "href": "api/ElectricDrill.AstraRpgHealth.Damage.CalculationPipeline.ApplyBarrierStep.html",
    "title": "Class ApplyBarrierStep | Astra RPG Health",
    "summary": "Class ApplyBarrierStep Namespace ElectricDrill.AstraRpgHealth.Damage.CalculationPipeline Assembly com.electricdrill.astra-rpg-health.Runtime.dll Damage step that consumes target barrier (temporary shields). It doesn't remove health. public class ApplyBarrierStep : DamageStep Inheritance object DamageStep ApplyBarrierStep Inherited Members DamageStep.Process(DamageInfo) Properties DisplayName Human readable name shown in pipeline editors. public override string DisplayName { get; } Property Value string Methods ProcessStep(DamageInfo) Applies the target's barrier to reduce the current damage amount. If the damage type ignores barrier, or the target has no barrier, the method returns the input unchanged. When barrier is consumed the target's barrier value is reduced accordingly. If the barrier completely absorbs the damage, PipelineReducedToZero is added. public override DamageInfo ProcessStep(DamageInfo data) Parameters data DamageInfo Current damage pipeline data. Returns DamageInfo The same data instance updated with reduced amounts and any barrier consumption."
  },
  "api/ElectricDrill.AstraRpgHealth.Damage.CalculationPipeline.ApplyCriticalMultiplierStep.html": {
    "href": "api/ElectricDrill.AstraRpgHealth.Damage.CalculationPipeline.ApplyCriticalMultiplierStep.html",
    "title": "Class ApplyCriticalMultiplierStep | Astra RPG Health",
    "summary": "Class ApplyCriticalMultiplierStep Namespace ElectricDrill.AstraRpgHealth.Damage.CalculationPipeline Assembly com.electricdrill.astra-rpg-health.Runtime.dll Damage step that applies critical hit multipliers when the current damage is flagged as critical. public class ApplyCriticalMultiplierStep : DamageStep Inheritance object DamageStep ApplyCriticalMultiplierStep Inherited Members DamageStep.Process(DamageInfo) Properties DisplayName Human readable name shown in pipeline editors. public override string DisplayName { get; } Property Value string Methods ProcessStep(DamageInfo) Multiplies the current damage by the critical multiplier from DamageInfo when the hit is marked critical. If the multiplier is 1 or invalid, no change occurs. public override DamageInfo ProcessStep(DamageInfo data) Parameters data DamageInfo Current damage pipeline data. Returns DamageInfo The same data instance updated with the multiplied amount when applicable."
  },
  "api/ElectricDrill.AstraRpgHealth.Damage.CalculationPipeline.ApplyDefenseStep.html": {
    "href": "api/ElectricDrill.AstraRpgHealth.Damage.CalculationPipeline.ApplyDefenseStep.html",
    "title": "Class ApplyDefenseStep | Astra RPG Health",
    "summary": "Class ApplyDefenseStep Namespace ElectricDrill.AstraRpgHealth.Damage.CalculationPipeline Assembly com.electricdrill.astra-rpg-health.Runtime.dll Damage step that applies defensive calculations based on the damage type's defensive and piercing stats and configured reduction functions. public class ApplyDefenseStep : DamageStep Inheritance object DamageStep ApplyDefenseStep Inherited Members DamageStep.Process(DamageInfo) Properties DisplayName Human readable name shown in pipeline editors. public override string DisplayName { get; } Property Value string Methods ProcessStep(DamageInfo) Applies defense and damage reduction logic using the damage type's configuration. If the damage type is inconsistently configured the method logs a warning and skips the corresponding reduction stage. public override DamageInfo ProcessStep(DamageInfo data) Parameters data DamageInfo Current damage pipeline data. Returns DamageInfo The same data instance updated with the reduced amount."
  },
  "api/ElectricDrill.AstraRpgHealth.Damage.CalculationPipeline.ApplyDmgModifiersStep.html": {
    "href": "api/ElectricDrill.AstraRpgHealth.Damage.CalculationPipeline.ApplyDmgModifiersStep.html",
    "title": "Class ApplyDmgModifiersStep | Astra RPG Health",
    "summary": "Class ApplyDmgModifiersStep Namespace ElectricDrill.AstraRpgHealth.Damage.CalculationPipeline Assembly com.electricdrill.astra-rpg-health.Runtime.dll Damage step that applies generic and configured damage source/type modifiers (for example weaknesses and resistances) to the current damage amount. public class ApplyDmgModifiersStep : DamageStep Inheritance object DamageStep ApplyDmgModifiersStep Inherited Members DamageStep.Process(DamageInfo) Properties DisplayName Human readable name shown in pipeline editors. public override string DisplayName { get; } Property Value string Methods ProcessStep(DamageInfo) Applies configured percentage-based modifiers to Amounts. If the configured adjustments lead to immunity or a terminal prevention condition the method will mark the DamageInfo with the appropriate DamagePreventionReason. public override DamageInfo ProcessStep(DamageInfo data) Parameters data DamageInfo Current damage pipeline data. Returns DamageInfo The same data instance updated with the modified amounts and any prevention reasons."
  },
  "api/ElectricDrill.AstraRpgHealth.Damage.CalculationPipeline.DamageCalculationStrategy.html": {
    "href": "api/ElectricDrill.AstraRpgHealth.Damage.CalculationPipeline.DamageCalculationStrategy.html",
    "title": "Class DamageCalculationStrategy | Astra RPG Health",
    "summary": "Class DamageCalculationStrategy Namespace ElectricDrill.AstraRpgHealth.Damage.CalculationPipeline Assembly com.electricdrill.astra-rpg-health.Runtime.dll ScriptableObject that defines a configurable damage calculation pipeline. The pipeline is composed of ordered DamageStep instances executed sequentially. [CreateAssetMenu(fileName = \"New Configurable Strategy\", menuName = \"Astra RPG Health/Damage Calculation Pipeline/Configurable Strategy\")] public class DamageCalculationStrategy : ScriptableObject Inheritance object Object ScriptableObject DamageCalculationStrategy Fields steps Ordered list of steps composing this calculation strategy. Steps are executed in sequence. [SerializeReference] public List<DamageStep> steps Field Value List<DamageStep> Methods CalculateDamage(DamageInfo) Executes the entire damage calculation pipeline defined in this asset. public virtual DamageInfo CalculateDamage(DamageInfo data) Parameters data DamageInfo The initial damage information. Returns DamageInfo The damage information after all steps have been applied."
  },
  "api/ElectricDrill.AstraRpgHealth.Damage.CalculationPipeline.DamageInfo.html": {
    "href": "api/ElectricDrill.AstraRpgHealth.Damage.CalculationPipeline.DamageInfo.html",
    "title": "Class DamageInfo | Astra RPG Health",
    "summary": "Class DamageInfo Namespace ElectricDrill.AstraRpgHealth.Damage.CalculationPipeline Assembly com.electricdrill.astra-rpg-health.Runtime.dll Container for damage pipeline state while a damage calculation is executed. Holds the amounts being transformed, the source/type metadata and accumulated prevention reasons. public class DamageInfo Inheritance object DamageInfo Constructors DamageInfo(PreDamageInfo) Creates a new DamageInfo from the provided PreDamageInfo. The constructor initializes amounts, metadata and sets pre-phase prevention reasons if applicable. public DamageInfo(PreDamageInfo pre) Parameters pre PreDamageInfo The immutable pre-damage description used to initialize this instance. Properties Amounts Numeric amounts and intermediate records for the damage being processed. public DamageAmountInfo Amounts { get; set; } Property Value DamageAmountInfo CriticalMultiplier Critical multiplier applied when IsCritical is true (1.0 means no change). public double CriticalMultiplier { get; } Property Value double DamageSource The origin/source of the damage (spell, environmental, trap, etc.). public DamageSource DamageSource { get; } Property Value DamageSource Dealer Entity that deals the damage (may be the same as target for self damage or null for environmental damage). public EntityCore Dealer { get; } Property Value EntityCore IsCritical Indicates whether the incoming hit was marked as critical. public bool IsCritical { get; } Property Value bool IsPrevented Returns true when accumulated reasons include a terminal prevention condition. public bool IsPrevented { get; } Property Value bool Reasons Reasons accumulated through the pipeline that caused damage to be prevented. This is a flag enum that can contain multiple reasons. public DamagePreventionReason Reasons { get; } Property Value DamagePreventionReason Target Entity that is the target of this damage calculation. public EntityCore Target { get; } Property Value EntityCore TerminationStepType DamageStep that caused termination of the pipeline. public Type TerminationStepType { get; } Property Value Type Type Configured damage type describing how the damage behaves (defenses, true, etc.). public DamageType Type { get; } Property Value DamageType Methods AddReason(DamagePreventionReason, Type, bool) Adds a prevention reason to the accumulated flags and optionally marks the termination step. public void AddReason(DamagePreventionReason reason, Type stepType, bool terminate = true) Parameters reason DamagePreventionReason Reason to add. stepType Type Type of the step that added the reason (can be null for pre-phase). terminate bool If true and the termination step is not already set, records stepType as the termination cause."
  },
  "api/ElectricDrill.AstraRpgHealth.Damage.CalculationPipeline.DamageStep.html": {
    "href": "api/ElectricDrill.AstraRpgHealth.Damage.CalculationPipeline.DamageStep.html",
    "title": "Class DamageStep | Astra RPG Health",
    "summary": "Class DamageStep Namespace ElectricDrill.AstraRpgHealth.Damage.CalculationPipeline Assembly com.electricdrill.astra-rpg-health.Runtime.dll Base class for a single step in the damage calculation pipeline. A DamageStep performs a focused transformation on a DamageInfo instance (for example applying defenses, barriers or modifiers). [Serializable] public abstract class DamageStep Inheritance object DamageStep Derived ApplyBarrierStep ApplyCriticalMultiplierStep ApplyDefenseStep ApplyDmgModifiersStep Properties DisplayName Human-readable name shown in editors and logs for this step. Implementations should return a short descriptive label. public abstract string DisplayName { get; } Property Value string Methods Process(DamageInfo) Entry point executed by the pipeline runner. This method enforces common preconditions (skipping when already prevented or when the current amount is <= 0), invokes ProcessStep(DamageInfo), records the before/after amounts for tracing and sets the PipelineReducedToZero reason when a step reduces a positive amount to zero or less. public DamageInfo Process(DamageInfo data) Parameters data DamageInfo The pipeline state being processed. Returns DamageInfo The same data instance, potentially modified by the step. ProcessStep(DamageInfo) Implement this method in derived classes to perform the actual transformation of the pipeline state. public abstract DamageInfo ProcessStep(DamageInfo data) Parameters data DamageInfo Pipeline state to process. Implementations should mutate this instance to reflect changes. Returns DamageInfo The modified data instance."
  },
  "api/ElectricDrill.AstraRpgHealth.Damage.CalculationPipeline.html": {
    "href": "api/ElectricDrill.AstraRpgHealth.Damage.CalculationPipeline.html",
    "title": "Namespace ElectricDrill.AstraRpgHealth.Damage.CalculationPipeline | Astra RPG Health",
    "summary": "Namespace ElectricDrill.AstraRpgHealth.Damage.CalculationPipeline Classes ApplyBarrierStep Damage step that consumes target barrier (temporary shields). It doesn't remove health. ApplyCriticalMultiplierStep Damage step that applies critical hit multipliers when the current damage is flagged as critical. ApplyDefenseStep Damage step that applies defensive calculations based on the damage type's defensive and piercing stats and configured reduction functions. ApplyDmgModifiersStep Damage step that applies generic and configured damage source/type modifiers (for example weaknesses and resistances) to the current damage amount. DamageCalculationStrategy ScriptableObject that defines a configurable damage calculation pipeline. The pipeline is composed of ordered DamageStep instances executed sequentially. DamageInfo Container for damage pipeline state while a damage calculation is executed. Holds the amounts being transformed, the source/type metadata and accumulated prevention reasons. DamageStep Base class for a single step in the damage calculation pipeline. A DamageStep performs a focused transformation on a DamageInfo instance (for example applying defenses, barriers or modifiers)."
  },
  "api/ElectricDrill.AstraRpgHealth.Damage.DamageAmountInfo.StepAmountRecord.html": {
    "href": "api/ElectricDrill.AstraRpgHealth.Damage.DamageAmountInfo.StepAmountRecord.html",
    "title": "Struct DamageAmountInfo.StepAmountRecord | Astra RPG Health",
    "summary": "Struct DamageAmountInfo.StepAmountRecord Namespace ElectricDrill.AstraRpgHealth.Damage Assembly com.electricdrill.astra-rpg-health.Runtime.dll Immutable record representing the damage value before and after a single pipeline phase (identified by the phase type). public readonly struct DamageAmountInfo.StepAmountRecord Constructors StepAmountRecord(Type, long, long) Creates a new record for a phase with the associated before/after values. public StepAmountRecord(Type stepType, long pre, long post) Parameters stepType Type Phase type. pre long Value before the phase. post long Value after the phase. Properties Post Damage value immediately after the phase executes. public long Post { get; } Property Value long Pre Damage value immediately before the phase executes. public long Pre { get; } Property Value long StepType The type that represents the phase (for example, a reduction class). May be null for uninitialized or default records. public Type StepType { get; } Property Value Type Methods ToString() Compact textual representation of the record, useful for logging. public override string ToString() Returns string String in the format \"{TypeName}: {Pre} -> {Post}\"."
  },
  "api/ElectricDrill.AstraRpgHealth.Damage.DamageAmountInfo.html": {
    "href": "api/ElectricDrill.AstraRpgHealth.Damage.DamageAmountInfo.html",
    "title": "Class DamageAmountInfo | Astra RPG Health",
    "summary": "Class DamageAmountInfo Namespace ElectricDrill.AstraRpgHealth.Damage Assembly com.electricdrill.astra-rpg-health.Runtime.dll Holds numeric details related to an attempt to apply damage, allowing intermediate values to be recorded for each phase of the calculation pipeline (e.g. reductions, resistances, absorptions). public class DamageAmountInfo Inheritance object DamageAmountInfo Remarks This class is mutable for Current and keeps a list of DamageAmountInfo.StepAmountRecord entries that describe the value before and after each step. It is used to trace how the initial raw value is transformed into the final damage applied. Constructors DamageAmountInfo(long) Creates a new instance of DamageAmountInfo with the provided initial value. public DamageAmountInfo(long initialAmount) Parameters initialAmount long Raw starting damage value. Properties Current The current damage value during calculation; updated by the various phases. The value is clamped to a minimum of 0. public long Current { get; set; } Property Value long InitialAmount The raw initial value provided to the damage calculation pipeline. public long InitialAmount { get; } Property Value long Records Read-only list of the recorded phase entries in order. public IReadOnlyList<DamageAmountInfo.StepAmountRecord> Records { get; } Property Value IReadOnlyList<DamageAmountInfo.StepAmountRecord> Methods FromRaw(long) Convenience factory that builds a DamageAmountInfo from a raw value; equivalent to using the public constructor. public static DamageAmountInfo FromRaw(long raw) Parameters raw long Raw damage value. Returns DamageAmountInfo A new DamageAmountInfo initialized to raw. GetStepAmount(Type) Retrieves the record associated with a given phase identified by its type. public DamageAmountInfo.StepAmountRecord GetStepAmount(Type stepType) Parameters stepType Type The phase type to look up. Returns DamageAmountInfo.StepAmountRecord The corresponding DamageAmountInfo.StepAmountRecord or the default if not found. Remarks If no matching record exists the default value of DamageAmountInfo.StepAmountRecord is returned (with StepType possibly null)."
  },
  "api/ElectricDrill.AstraRpgHealth.Damage.DamageOutcome.html": {
    "href": "api/ElectricDrill.AstraRpgHealth.Damage.DamageOutcome.html",
    "title": "Enum DamageOutcome | Astra RPG Health",
    "summary": "Enum DamageOutcome Namespace ElectricDrill.AstraRpgHealth.Damage Assembly com.electricdrill.astra-rpg-health.Runtime.dll The overall result of attempting to apply damage to a target. Use this in DamageResolution to indicate whether any damage was applied or if the attempt was prevented. public enum DamageOutcome Fields Applied = 0 The damage was applied to the target's health/defenses. See FinalDamageInfo for details. Prevented = 1 The damage attempt was prevented. See Reasons for prevention reasons."
  },
  "api/ElectricDrill.AstraRpgHealth.Damage.DamagePreventionReason.html": {
    "href": "api/ElectricDrill.AstraRpgHealth.Damage.DamagePreventionReason.html",
    "title": "Enum DamagePreventionReason | Astra RPG Health",
    "summary": "Enum DamagePreventionReason Namespace ElectricDrill.AstraRpgHealth.Damage Assembly com.electricdrill.astra-rpg-health.Runtime.dll Flags that explain why a damage attempt was prevented. Multiple reasons may be combined. These flags are used in Reasons when an attempt is prevented. [Flags] public enum DamagePreventionReason Extension Methods DamagePreventionReasonExtensions.IsTerminal(DamagePreventionReason) Fields AllDamageImmune = 2 The target is immune to all damage because of its generic damage reduction stat value. BarrierAbsorbed = 16 The target's barrier fully absorbed the damage. DamageSourceImmune = 8 The target is immune to the specific DamageSource that originated the damage. DamageTypeImmune = 4 The target is immune to this specific DamageType. DefenseAbsorbed = 32 The target's stat defense for the damage type fully absorbed the damage. EntityDead = 512 The target was already dead when the damage would have been applied. EntityImmune = 1 The target entity is immune to all damage (global immunity). None = 0 No prevention; damage can proceed. PipelineReducedToZero = 256 After reductions, a pipeline step reduced the damage to zero and nothing was applied. PrePhaseIgnored = 64 The pre-processing phase explicitly ignored the damage (for example by a passive ability that intercepted the PreDmgGameEvent and instructed the PreDamageInfo to ignore it). PrePhaseZeroAmount = 128 The damage amount was zero in the pre-phase and therefore not applied."
  },
  "api/ElectricDrill.AstraRpgHealth.Damage.DamagePreventionReasonExtensions.html": {
    "href": "api/ElectricDrill.AstraRpgHealth.Damage.DamagePreventionReasonExtensions.html",
    "title": "Class DamagePreventionReasonExtensions | Astra RPG Health",
    "summary": "Class DamagePreventionReasonExtensions Namespace ElectricDrill.AstraRpgHealth.Damage Assembly com.electricdrill.astra-rpg-health.Runtime.dll Extension helpers for DamagePreventionReason. public static class DamagePreventionReasonExtensions Inheritance object DamagePreventionReasonExtensions Methods IsTerminal(DamagePreventionReason) Returns true when the provided set of reasons indicates a terminal prevention state (i.e. any prevention reason is present). False when None. public static bool IsTerminal(this DamagePreventionReason reasons) Parameters reasons DamagePreventionReason Returns bool"
  },
  "api/ElectricDrill.AstraRpgHealth.Damage.DamageResolution.html": {
    "href": "api/ElectricDrill.AstraRpgHealth.Damage.DamageResolution.html",
    "title": "Class DamageResolution | Astra RPG Health",
    "summary": "Class DamageResolution Namespace ElectricDrill.AstraRpgHealth.Damage Assembly com.electricdrill.astra-rpg-health.Runtime.dll The result returned by damage application attempts. Encapsulates whether the damage was applied or prevented, the reasons for prevention, and the concrete damage information that was ultimately applied (if any). public class DamageResolution Inheritance object DamageResolution Properties FinalDamageInfo The final computed damage information that was applied to the target. This is non-null only when Outcome is Applied. The contained DamageInfo includes applied amount, barrier/health split, termination step type and any additional diagnostics produced by the pipeline. public DamageInfo FinalDamageInfo { get; } Property Value DamageInfo Outcome The high-level outcome of the attempt: either Applied or Prevented. public DamageOutcome Outcome { get; } Property Value DamageOutcome PreInfo The original PreDamageInfo that triggered this resolution. Useful for logging and diagnostic correlation. public PreDamageInfo PreInfo { get; } Property Value PreDamageInfo Reasons When Outcome is Prevented, this contains the combined DamagePreventionReason flags explaining why. It will be None when Outcome is Applied. public DamagePreventionReason Reasons { get; } Property Value DamagePreventionReason TerminationStepType If the pipeline execution terminated early, this will contain the System.Type of the pipeline termination step that decided to stop processing. May be null when the pipeline completed normally. public Type TerminationStepType { get; } Property Value Type Methods Applied(DamageInfo, PreDamageInfo) Create a DamageResolution representing an applied damage attempt. The info parameter contains the concrete damage values applied. public static DamageResolution Applied(DamageInfo info, PreDamageInfo pre) Parameters info DamageInfo Final damage info that was applied. pre PreDamageInfo Original pre-damage request. Returns DamageResolution A configured DamageResolution with Outcome == Applied. Prevented(DamagePreventionReason, PreDamageInfo, DamageInfo) Create a DamageResolution representing a prevented damage attempt. reasons should explain why the attempt didn't apply. Optionally the info parameter may contain a partial DamageInfo produced before prevention. public static DamageResolution Prevented(DamagePreventionReason reasons, PreDamageInfo pre, DamageInfo info = null) Parameters reasons DamagePreventionReason Flags explaining the prevention. pre PreDamageInfo Original pre-damage request. info DamageInfo Optional partial damage info produced before prevention. Returns DamageResolution A configured DamageResolution with Outcome == Prevented."
  },
  "api/ElectricDrill.AstraRpgHealth.Damage.DamageSource.html": {
    "href": "api/ElectricDrill.AstraRpgHealth.Damage.DamageSource.html",
    "title": "Class DamageSource | Astra RPG Health",
    "summary": "Class DamageSource Namespace ElectricDrill.AstraRpgHealth.Damage Assembly com.electricdrill.astra-rpg-health.Runtime.dll Defines a damage source asset that identifies how damage was produced (for example: a spell, trap, environmental hazard, system event, etc.). Create instances via Assets -> Create -> Astra RPG Health / Damage Source. [CreateAssetMenu(fileName = \"New Damage Source\", menuName = \"Astra RPG Health/Damage Source\")] public class DamageSource : ScriptableObject Inheritance object Object ScriptableObject DamageSource Methods ToString() Returns the asset name of this damage source. public override string ToString() Returns string"
  },
  "api/ElectricDrill.AstraRpgHealth.Damage.DamageType.html": {
    "href": "api/ElectricDrill.AstraRpgHealth.Damage.DamageType.html",
    "title": "Class DamageType | Astra RPG Health",
    "summary": "Class DamageType Namespace ElectricDrill.AstraRpgHealth.Damage Assembly com.electricdrill.astra-rpg-health.Runtime.dll Scriptable asset that describes a damage category (for example: Physical, Fire, Poison). A DamageType declares which stat reduces this damage, which reduction functions to use, whether a stat pierces its defensive stats and whether it ignores barriers. Create instances via Assets -> Create -> Astra RPG Health / DamageType. [CreateAssetMenu(fileName = \"New Damage Type\", menuName = \"Astra RPG Health/DamageType\")] public class DamageType : ScriptableObject Inheritance object Object ScriptableObject DamageType Properties DamageReductionFn The reduction function used to compute how the damage amount is modified by the reducing stat (see ReducedBy). This may implement flat, percentage, logarithmic, or custom reduction behaviour. public DamageReductionFn DamageReductionFn { get; } Property Value DamageReductionFn DefenseReductionFn The reduction function used to compute how the piercing stat modifies the defensive stat that reduces damage for this DamageType. This may implement flat, percentage, logarithmic, or custom reduction behaviour. public DefenseReductionFn DefenseReductionFn { get; } Property Value DefenseReductionFn DefensiveStatPiercedBy The stat that pierces the defensive stat for this damage type (for example an \"Armor Penetration\" stat pierces the \"Armor\" stat). May be null. public Stat DefensiveStatPiercedBy { get; } Property Value Stat IgnoresBarrier If true, this damage type bypasses barrier mechanic and applies directly to underlying health. Typical use: certain elemental or pure damage types. public bool IgnoresBarrier { get; protected set; } Property Value bool ReducedBy The stat that reduces the raw damage amount for this DamageType. For example Physical damage may be reduced by an \"Armor\" stat. public Stat ReducedBy { get; } Property Value Stat Methods ToString() Returns the asset name of this damage type. public override string ToString() Returns string"
  },
  "api/ElectricDrill.AstraRpgHealth.Damage.IDamageable.html": {
    "href": "api/ElectricDrill.AstraRpgHealth.Damage.IDamageable.html",
    "title": "Interface IDamageable | Astra RPG Health",
    "summary": "Interface IDamageable Namespace ElectricDrill.AstraRpgHealth.Damage Assembly com.electricdrill.astra-rpg-health.Runtime.dll Implemented by entities that can receive damage. The TakeDamage(PreDamageInfo) method accepts a PreDamageInfo record describing a pending damage attempt and returns a DamageResolution describing whether the damage was applied or prevented and additional details. public interface IDamageable Methods TakeDamage(PreDamageInfo) Process an incoming damage request and return a resolution object. Implementations should run the damage processing pipeline (pre-phase, reduction, defensive checks, barriers, health application) or delegate to the centralized pipeline host used in the project. The provided preDamage describes the intent (amount, type, source, critical flags, target/dealer). The returned DamageResolution must reflect the final outcome: If damage was applied, an instance created with Applied(DamageInfo, PreDamageInfo) is expected and FinalDamageInfo will contain the concrete damage values that were actually applied to the target. If the damage was prevented (for example due to immunity, zero amount after reductions, or an explicit ignore), an instance created with Prevented(DamagePreventionReason, PreDamageInfo, DamageInfo) is expected. Implementations SHOULD NOT throw for normal prevention cases; use the prevention reasons and the returned resolution to communicate why the damage didn't apply. DamageResolution TakeDamage(PreDamageInfo preDamage) Parameters preDamage PreDamageInfo Immutable description of the pending damage attempt. Returns DamageResolution A DamageResolution describing the final outcome and details."
  },
  "api/ElectricDrill.AstraRpgHealth.Damage.PreDamageInfo.DamageInfoAmount.html": {
    "href": "api/ElectricDrill.AstraRpgHealth.Damage.PreDamageInfo.DamageInfoAmount.html",
    "title": "Interface PreDamageInfo.DamageInfoAmount | Astra RPG Health",
    "summary": "Interface PreDamageInfo.DamageInfoAmount Namespace ElectricDrill.AstraRpgHealth.Damage Assembly com.electricdrill.astra-rpg-health.Runtime.dll Fluent builder step: specify the damage amount. public interface PreDamageInfo.DamageInfoAmount Methods WithAmount(long) Set the damage amount and advance to the next step. PreDamageInfo.DamageInfoType WithAmount(long amount) Parameters amount long Returns PreDamageInfo.DamageInfoType"
  },
  "api/ElectricDrill.AstraRpgHealth.Damage.PreDamageInfo.DamageInfoDealer.html": {
    "href": "api/ElectricDrill.AstraRpgHealth.Damage.PreDamageInfo.DamageInfoDealer.html",
    "title": "Interface PreDamageInfo.DamageInfoDealer | Astra RPG Health",
    "summary": "Interface PreDamageInfo.DamageInfoDealer Namespace ElectricDrill.AstraRpgHealth.Damage Assembly com.electricdrill.astra-rpg-health.Runtime.dll Fluent builder step: specify the dealer entity. public interface PreDamageInfo.DamageInfoDealer Methods WithDealer(EntityCore) Set the damage dealer and obtain the concrete builder for optional extra flags. PreDamageInfo.PreDamageInfoStepBuilder WithDealer(EntityCore dealer) Parameters dealer EntityCore Returns PreDamageInfo.PreDamageInfoStepBuilder"
  },
  "api/ElectricDrill.AstraRpgHealth.Damage.PreDamageInfo.DamageInfoSource.html": {
    "href": "api/ElectricDrill.AstraRpgHealth.Damage.PreDamageInfo.DamageInfoSource.html",
    "title": "Interface PreDamageInfo.DamageInfoSource | Astra RPG Health",
    "summary": "Interface PreDamageInfo.DamageInfoSource Namespace ElectricDrill.AstraRpgHealth.Damage Assembly com.electricdrill.astra-rpg-health.Runtime.dll Fluent builder step: specify the damage source. public interface PreDamageInfo.DamageInfoSource Methods WithSource(DamageSource) Set the damage source and advance to the next step. PreDamageInfo.DamageInfoTarget WithSource(DamageSource damageSource) Parameters damageSource DamageSource Returns PreDamageInfo.DamageInfoTarget"
  },
  "api/ElectricDrill.AstraRpgHealth.Damage.PreDamageInfo.DamageInfoTarget.html": {
    "href": "api/ElectricDrill.AstraRpgHealth.Damage.PreDamageInfo.DamageInfoTarget.html",
    "title": "Interface PreDamageInfo.DamageInfoTarget | Astra RPG Health",
    "summary": "Interface PreDamageInfo.DamageInfoTarget Namespace ElectricDrill.AstraRpgHealth.Damage Assembly com.electricdrill.astra-rpg-health.Runtime.dll Fluent builder step: specify the target entity. public interface PreDamageInfo.DamageInfoTarget Methods WithTarget(EntityCore) Set the damage target and advance to the next step. PreDamageInfo.DamageInfoDealer WithTarget(EntityCore target) Parameters target EntityCore Returns PreDamageInfo.DamageInfoDealer"
  },
  "api/ElectricDrill.AstraRpgHealth.Damage.PreDamageInfo.DamageInfoType.html": {
    "href": "api/ElectricDrill.AstraRpgHealth.Damage.PreDamageInfo.DamageInfoType.html",
    "title": "Interface PreDamageInfo.DamageInfoType | Astra RPG Health",
    "summary": "Interface PreDamageInfo.DamageInfoType Namespace ElectricDrill.AstraRpgHealth.Damage Assembly com.electricdrill.astra-rpg-health.Runtime.dll Fluent builder step: specify the damage type. public interface PreDamageInfo.DamageInfoType Methods WithType(DamageType) Set the damage type and advance to the next step. PreDamageInfo.DamageInfoSource WithType(DamageType type) Parameters type DamageType Returns PreDamageInfo.DamageInfoSource"
  },
  "api/ElectricDrill.AstraRpgHealth.Damage.PreDamageInfo.PreDamageInfoStepBuilder.html": {
    "href": "api/ElectricDrill.AstraRpgHealth.Damage.PreDamageInfo.PreDamageInfoStepBuilder.html",
    "title": "Class PreDamageInfo.PreDamageInfoStepBuilder | Astra RPG Health",
    "summary": "Class PreDamageInfo.PreDamageInfoStepBuilder Namespace ElectricDrill.AstraRpgHealth.Damage Assembly com.electricdrill.astra-rpg-health.Runtime.dll Concrete step builder implementing the fluent interfaces. After setting required fields, optional flags (critical, multiplier) can be configured before calling Build(). public sealed class PreDamageInfo.PreDamageInfoStepBuilder : PreDamageInfo.DamageInfoAmount, PreDamageInfo.DamageInfoType, PreDamageInfo.DamageInfoSource, PreDamageInfo.DamageInfoTarget, PreDamageInfo.DamageInfoDealer Inheritance object PreDamageInfo.PreDamageInfoStepBuilder Implements PreDamageInfo.DamageInfoAmount PreDamageInfo.DamageInfoType PreDamageInfo.DamageInfoSource PreDamageInfo.DamageInfoTarget PreDamageInfo.DamageInfoDealer Methods Build() Build the PreDamageInfo instance with the previously configured values. public PreDamageInfo Build() Returns PreDamageInfo WithAmount(long) Set the damage amount. public PreDamageInfo.DamageInfoType WithAmount(long amount) Parameters amount long Returns PreDamageInfo.DamageInfoType WithCriticalMultiplier(double) Set the critical damage multiplier. Values <= 0 will be normalized to 1.0 by the constructor. public PreDamageInfo.PreDamageInfoStepBuilder WithCriticalMultiplier(double multiplier) Parameters multiplier double Returns PreDamageInfo.PreDamageInfoStepBuilder WithDealer(EntityCore) Set the dealer entity (the entity causing the damage). public PreDamageInfo.PreDamageInfoStepBuilder WithDealer(EntityCore dealer) Parameters dealer EntityCore Returns PreDamageInfo.PreDamageInfoStepBuilder WithIsCritical(bool) Mark this damage as critical or not. public PreDamageInfo.PreDamageInfoStepBuilder WithIsCritical(bool isCritical) Parameters isCritical bool Returns PreDamageInfo.PreDamageInfoStepBuilder WithSource(DamageSource) Set the damage source. public PreDamageInfo.DamageInfoTarget WithSource(DamageSource damageSource) Parameters damageSource DamageSource Returns PreDamageInfo.DamageInfoTarget WithTarget(EntityCore) Set the target entity that will receive the damage. public PreDamageInfo.DamageInfoDealer WithTarget(EntityCore target) Parameters target EntityCore Returns PreDamageInfo.DamageInfoDealer WithType(DamageType) Set the damage type. public PreDamageInfo.DamageInfoSource WithType(DamageType type) Parameters type DamageType Returns PreDamageInfo.DamageInfoSource"
  },
  "api/ElectricDrill.AstraRpgHealth.Damage.PreDamageInfo.html": {
    "href": "api/ElectricDrill.AstraRpgHealth.Damage.PreDamageInfo.html",
    "title": "Class PreDamageInfo | Astra RPG Health",
    "summary": "Class PreDamageInfo Namespace ElectricDrill.AstraRpgHealth.Damage Assembly com.electricdrill.astra-rpg-health.Runtime.dll Immutable container representing damage information before it is applied. Use Builder to construct instances using the fluent step builder. public class PreDamageInfo Inheritance object PreDamageInfo Properties Amount The raw damage amount (before modifiers). public long Amount { get; set; } Property Value long Builder Entry point for the fluent builder. Example: var pre = PreDamageInfo.Builder .WithAmount(10) .WithType(DamageType.Physical) .WithSource(DamageSource.Weapon) .WithTarget(targetEntity) .WithDealer(dealerEntity) .WithIsCritical(false) .Build(); public static PreDamageInfo.DamageInfoAmount Builder { get; } Property Value PreDamageInfo.DamageInfoAmount CriticalMultiplier Multiplier applied when this is critical damage. A value of 1.0 means no change. Values <= 0 are normalized to 1.0 by the constructor. public double CriticalMultiplier { get; set; } Property Value double DamageSource The source or reason for the damage (for example an ability or environmental effect). public DamageSource DamageSource { get; } Property Value DamageSource Dealer The entity that deals the damage (may be null for environmental damage). public EntityCore Dealer { get; } Property Value EntityCore Ignore If true, the damage will be ignored and not applied to the target. Use this in cases where the damage should be negated (e.g., passive abilities). public bool Ignore { get; set; } Property Value bool IsCritical Whether this damage instance was flagged as a critical hit. public bool IsCritical { get; set; } Property Value bool Target The entity that will receive the damage. public EntityCore Target { get; } Property Value EntityCore Type The type/category of the damage (e.g. physical, magical). public DamageType Type { get; set; } Property Value DamageType"
  },
  "api/ElectricDrill.AstraRpgHealth.Damage.html": {
    "href": "api/ElectricDrill.AstraRpgHealth.Damage.html",
    "title": "Namespace ElectricDrill.AstraRpgHealth.Damage | Astra RPG Health",
    "summary": "Namespace ElectricDrill.AstraRpgHealth.Damage Classes DamageAmountInfo Holds numeric details related to an attempt to apply damage, allowing intermediate values to be recorded for each phase of the calculation pipeline (e.g. reductions, resistances, absorptions). DamagePreventionReasonExtensions Extension helpers for DamagePreventionReason. DamageResolution The result returned by damage application attempts. Encapsulates whether the damage was applied or prevented, the reasons for prevention, and the concrete damage information that was ultimately applied (if any). DamageSource Defines a damage source asset that identifies how damage was produced (for example: a spell, trap, environmental hazard, system event, etc.). Create instances via Assets -> Create -> Astra RPG Health / Damage Source. DamageType Scriptable asset that describes a damage category (for example: Physical, Fire, Poison). A DamageType declares which stat reduces this damage, which reduction functions to use, whether a stat pierces its defensive stats and whether it ignores barriers. Create instances via Assets -> Create -> Astra RPG Health / DamageType. PreDamageInfo Immutable container representing damage information before it is applied. Use Builder to construct instances using the fluent step builder. PreDamageInfo.PreDamageInfoStepBuilder Concrete step builder implementing the fluent interfaces. After setting required fields, optional flags (critical, multiplier) can be configured before calling Build(). Structs DamageAmountInfo.StepAmountRecord Immutable record representing the damage value before and after a single pipeline phase (identified by the phase type). Interfaces IDamageable Implemented by entities that can receive damage. The TakeDamage(PreDamageInfo) method accepts a PreDamageInfo record describing a pending damage attempt and returns a DamageResolution describing whether the damage was applied or prevented and additional details. PreDamageInfo.DamageInfoAmount Fluent builder step: specify the damage amount. PreDamageInfo.DamageInfoDealer Fluent builder step: specify the dealer entity. PreDamageInfo.DamageInfoSource Fluent builder step: specify the damage source. PreDamageInfo.DamageInfoTarget Fluent builder step: specify the target entity. PreDamageInfo.DamageInfoType Fluent builder step: specify the damage type. Enums DamageOutcome The overall result of attempting to apply damage to a target. Use this in DamageResolution to indicate whether any damage was applied or if the attempt was prevented. DamagePreventionReason Flags that explain why a damage attempt was prevented. Multiple reasons may be combined. These flags are used in Reasons when an attempt is prevented."
  },
  "api/ElectricDrill.AstraRpgHealth.DamageReductionFunctions.DamageReductionFn.html": {
    "href": "api/ElectricDrill.AstraRpgHealth.DamageReductionFunctions.DamageReductionFn.html",
    "title": "Class DamageReductionFn | Astra RPG Health",
    "summary": "Class DamageReductionFn Namespace ElectricDrill.AstraRpgHealth.DamageReductionFunctions Assembly com.electricdrill.astra-rpg-health.Runtime.dll Base type for damage reduction functions. Implementations compute how an incoming damage amount is reduced using a defensive statistic value. public abstract class DamageReductionFn : ScriptableObject Inheritance object Object ScriptableObject DamageReductionFn Derived FlatDamageReductionFn LogDamageReductionFn PercentageDamageReductionFn Remarks Implementations return a non-negative integer amount of damage. Implementations are responsible for any rounding or clamping behavior (for example, ensuring the returned value is not negative). Methods ReducedDmg(long, double) Reduces the specified amount of damage using the provided defensive statistic value and returns the resulting damage amount. public abstract long ReducedDmg(long amount, double defensiveStatValue) Parameters amount long The original incoming damage amount to be reduced. defensiveStatValue double The value of the defensive statistic used to reduce damage (semantics depend on the implementation: absolute value, percentage, etc.). Returns long The reduced damage amount as a non-negative long. Implementations should ensure the returned value is >= 0 and apply any rounding semantics they require."
  },
  "api/ElectricDrill.AstraRpgHealth.DamageReductionFunctions.DamageReductionFunctions.FlatDamageReductionFn.html": {
    "href": "api/ElectricDrill.AstraRpgHealth.DamageReductionFunctions.DamageReductionFunctions.FlatDamageReductionFn.html",
    "title": "Class FlatDamageReductionFn | Astra RPG Health",
    "summary": "Class FlatDamageReductionFn Namespace ElectricDrill.AstraRpgHealth.DamageReductionFunctions.DamageReductionFunctions Assembly com.electricdrill.astra-rpg-health.Runtime.dll [CreateAssetMenu(fileName = \"Flat Damage Reduction Fn\", menuName = \"Astra RPG Health/Dmg Reduction Functions/Flat Dmg Reduction\")] public class FlatDamageReductionFn : DamageReductionFn Inheritance object Object ScriptableObject DamageReductionFn FlatDamageReductionFn Methods ReducedDmg(long, double) Subtracts defensiveStatValue * _factor from the incoming amount. The result is clamped to a minimum of 0 and rounded to the nearest whole number. public override long ReducedDmg(long amount, double defensiveStatValue) Parameters amount long Incoming damage amount. defensiveStatValue double Value of the defensive statistic used to reduce damage. This value is multiplied by ElectricDrill.AstraRpgHealth.DamageReductionFunctions.DamageReductionFunctions.FlatDamageReductionFn._factor before being subtracted. Returns long The reduced damage as a non-negative long (rounded)."
  },
  "api/ElectricDrill.AstraRpgHealth.DamageReductionFunctions.DamageReductionFunctions.LogDamageReductionFn.html": {
    "href": "api/ElectricDrill.AstraRpgHealth.DamageReductionFunctions.DamageReductionFunctions.LogDamageReductionFn.html",
    "title": "Class LogDamageReductionFn | Astra RPG Health",
    "summary": "Class LogDamageReductionFn Namespace ElectricDrill.AstraRpgHealth.DamageReductionFunctions.DamageReductionFunctions Assembly com.electricdrill.astra-rpg-health.Runtime.dll [CreateAssetMenu(fileName = \"Log Dmg Reduction Fn\", menuName = \"Astra RPG Health/Dmg Reduction Functions/Log Dmg Reduction\")] public class LogDamageReductionFn : DamageReductionFn Inheritance object Object ScriptableObject DamageReductionFn LogDamageReductionFn Methods ReducedDmg(long, double) Reduces damage using a logarithmic formula that produces diminishing returns as the defensive stat increases. public override long ReducedDmg(long amount, double defensiveStatValue) Parameters amount long Incoming damage amount. defensiveStatValue double Defensive statistic value used to compute the reduction multiplier. Returns long The reduced damage as a non-negative long (rounded). Remarks Formula: Reduced Damage = Damage * (BaseValue / (BaseValue + Log(1 + DefensiveStat * ScaleFactor))) If defensiveStatValue is zero or negative the original damage is returned. The final result is clamped to be non-negative and rounded to the nearest integer."
  },
  "api/ElectricDrill.AstraRpgHealth.DamageReductionFunctions.DamageReductionFunctions.PercentageDamageReductionFn.html": {
    "href": "api/ElectricDrill.AstraRpgHealth.DamageReductionFunctions.DamageReductionFunctions.PercentageDamageReductionFn.html",
    "title": "Class PercentageDamageReductionFn | Astra RPG Health",
    "summary": "Class PercentageDamageReductionFn Namespace ElectricDrill.AstraRpgHealth.DamageReductionFunctions.DamageReductionFunctions Assembly com.electricdrill.astra-rpg-health.Runtime.dll [CreateAssetMenu(fileName = \"Percentage Dmg Reduction Fn\", menuName = \"Astra RPG Health/Dmg Reduction Functions/Percentage Dmg Reduction\")] public class PercentageDamageReductionFn : DamageReductionFn Inheritance object Object ScriptableObject DamageReductionFn PercentageDamageReductionFn Methods ReducedDmg(long, double) Reduces damage by a percentage determined by defensiveStatValue. Example: defensiveStatValue == 25 -> damage reduced by 25%. public override long ReducedDmg(long amount, double defensiveStatValue) Parameters amount long Incoming damage amount. defensiveStatValue double Percentage (0..100+). Treated as a percent reduction of the incoming damage. Returns long The reduced damage as a non-negative long (rounded). Remarks The computation is: reducedAmount = amount - amount * defensiveStatValue / 100.0 The result is clamped to a minimum of 0 and rounded to the nearest integer."
  },
  "api/ElectricDrill.AstraRpgHealth.DamageReductionFunctions.DamageReductionFunctions.html": {
    "href": "api/ElectricDrill.AstraRpgHealth.DamageReductionFunctions.DamageReductionFunctions.html",
    "title": "Namespace ElectricDrill.AstraRpgHealth.DamageReductionFunctions.DamageReductionFunctions | Astra RPG Health",
    "summary": "Namespace ElectricDrill.AstraRpgHealth.DamageReductionFunctions.DamageReductionFunctions Classes FlatDamageReductionFn LogDamageReductionFn PercentageDamageReductionFn"
  },
  "api/ElectricDrill.AstraRpgHealth.DamageReductionFunctions.html": {
    "href": "api/ElectricDrill.AstraRpgHealth.DamageReductionFunctions.html",
    "title": "Namespace ElectricDrill.AstraRpgHealth.DamageReductionFunctions | Astra RPG Health",
    "summary": "Namespace ElectricDrill.AstraRpgHealth.DamageReductionFunctions Classes DamageReductionFn Base type for damage reduction functions. Implementations compute how an incoming damage amount is reduced using a defensive statistic value."
  },
  "api/ElectricDrill.AstraRpgHealth.Death.DestroyOnDeathStrategy.html": {
    "href": "api/ElectricDrill.AstraRpgHealth.Death.DestroyOnDeathStrategy.html",
    "title": "Class DestroyOnDeathStrategy | Astra RPG Health",
    "summary": "Class DestroyOnDeathStrategy Namespace ElectricDrill.AstraRpgHealth.Death Assembly com.electricdrill.astra-rpg-health.Runtime.dll A death strategy that destroys the entity's GameObject when it dies. This is provided as a ScriptableObject to be reused across entities. Create instances via Assets -> Create -> Astra RPG Health / Death strategies / Destroy. [CreateAssetMenu(fileName = \"Destroy On Death Strategy\", menuName = \"Astra RPG Health/Death strategies/Destroy\")] public class DestroyOnDeathStrategy : OnDeathStrategy Inheritance object Object ScriptableObject OnDeathStrategy DestroyOnDeathStrategy Methods Die(EntityHealth) Destroys the GameObject associated with entityHealth. public override void Die(EntityHealth entityHealth) Parameters entityHealth EntityHealth The EntityHealth instance to destroy."
  },
  "api/ElectricDrill.AstraRpgHealth.Death.DisableOnDeathStrategy.html": {
    "href": "api/ElectricDrill.AstraRpgHealth.Death.DisableOnDeathStrategy.html",
    "title": "Class DisableOnDeathStrategy | Astra RPG Health",
    "summary": "Class DisableOnDeathStrategy Namespace ElectricDrill.AstraRpgHealth.Death Assembly com.electricdrill.astra-rpg-health.Runtime.dll A death strategy that disables the entity's GameObject when it dies. This is useful for entities that should be hidden but not destroyed, allowing for resurrection. Pairs well with EnableOnResurrectionStrategy to re-enable the GameObject on resurrection. Provided as a ScriptableObject for easy assignment in the editor. Create instances via Assets -> Create -> Astra RPG Health / Death strategies / Disable. [CreateAssetMenu(fileName = \"Disable On Death Strategy\", menuName = \"Astra RPG Health/Death strategies/Disable\")] public class DisableOnDeathStrategy : OnDeathStrategy Inheritance object Object ScriptableObject OnDeathStrategy DisableOnDeathStrategy Methods Die(EntityHealth) Disables the GameObject associated with entityHealth. public override void Die(EntityHealth entityHealth) Parameters entityHealth EntityHealth The EntityHealth instance that died."
  },
  "api/ElectricDrill.AstraRpgHealth.Death.DoNothingOnDeathStrategy.html": {
    "href": "api/ElectricDrill.AstraRpgHealth.Death.DoNothingOnDeathStrategy.html",
    "title": "Class DoNothingOnDeathStrategy | Astra RPG Health",
    "summary": "Class DoNothingOnDeathStrategy Namespace ElectricDrill.AstraRpgHealth.Death Assembly com.electricdrill.astra-rpg-health.Runtime.dll A no-op death strategy. Use this when no action is required upon an entity's death. Provided as a ScriptableObject for easy assignment in the editor. Create instances via Assets -> Create -> Astra RPG Health / Death strategies / Do Nothing. [CreateAssetMenu(fileName = \"Do Nothing On Death Strategy\", menuName = \"Astra RPG Health/Death strategies/Do Nothing\")] public class DoNothingOnDeathStrategy : OnDeathStrategy Inheritance object Object ScriptableObject OnDeathStrategy DoNothingOnDeathStrategy Methods Die(EntityHealth) Intentionally performs no action when an entity dies. public override void Die(EntityHealth entityHealth) Parameters entityHealth EntityHealth The EntityHealth instance that died (unused)."
  },
  "api/ElectricDrill.AstraRpgHealth.Death.MultipleOnDeathStrategy.html": {
    "href": "api/ElectricDrill.AstraRpgHealth.Death.MultipleOnDeathStrategy.html",
    "title": "Class MultipleOnDeathStrategy | Astra RPG Health",
    "summary": "Class MultipleOnDeathStrategy Namespace ElectricDrill.AstraRpgHealth.Death Assembly com.electricdrill.astra-rpg-health.Runtime.dll A death strategy that executes multiple death strategies in order. This allows combining multiple death behaviors without creating new strategy classes. Provided as a ScriptableObject for easy assignment in the editor. Create instances via Assets -> Create -> Astra RPG Health / Death strategies / Multiple. [CreateAssetMenu(fileName = \"Multiple On Death Strategy\", menuName = \"Astra RPG Health/Death strategies/Multiple\")] public class MultipleOnDeathStrategy : OnDeathStrategy Inheritance object Object ScriptableObject OnDeathStrategy MultipleOnDeathStrategy Methods Die(EntityHealth) Executes all configured death strategies in order. Null strategies in the list are skipped. public override void Die(EntityHealth entityHealth) Parameters entityHealth EntityHealth The EntityHealth instance that died."
  },
  "api/ElectricDrill.AstraRpgHealth.Death.OnDeathStrategy.html": {
    "href": "api/ElectricDrill.AstraRpgHealth.Death.OnDeathStrategy.html",
    "title": "Class OnDeathStrategy | Astra RPG Health",
    "summary": "Class OnDeathStrategy Namespace ElectricDrill.AstraRpgHealth.Death Assembly com.electricdrill.astra-rpg-health.Runtime.dll Base strategy type for handling an entity's death. Derive from this class and implement Die(EntityHealth) to define custom death behavior. public abstract class OnDeathStrategy : ScriptableObject Inheritance object Object ScriptableObject OnDeathStrategy Derived DestroyOnDeathStrategy DisableOnDeathStrategy DoNothingOnDeathStrategy MultipleOnDeathStrategy Methods Die(EntityHealth) Invoked when an entity should die. Implementations should perform any cleanup, state changes, or destruction logic here. public abstract void Die(EntityHealth entityHealth) Parameters entityHealth EntityHealth The EntityHealth instance representing the entity that died."
  },
  "api/ElectricDrill.AstraRpgHealth.Death.html": {
    "href": "api/ElectricDrill.AstraRpgHealth.Death.html",
    "title": "Namespace ElectricDrill.AstraRpgHealth.Death | Astra RPG Health",
    "summary": "Namespace ElectricDrill.AstraRpgHealth.Death Classes DestroyOnDeathStrategy A death strategy that destroys the entity's GameObject when it dies. This is provided as a ScriptableObject to be reused across entities. Create instances via Assets -> Create -> Astra RPG Health / Death strategies / Destroy. DisableOnDeathStrategy A death strategy that disables the entity's GameObject when it dies. This is useful for entities that should be hidden but not destroyed, allowing for resurrection. Pairs well with EnableOnResurrectionStrategy to re-enable the GameObject on resurrection. Provided as a ScriptableObject for easy assignment in the editor. Create instances via Assets -> Create -> Astra RPG Health / Death strategies / Disable. DoNothingOnDeathStrategy A no-op death strategy. Use this when no action is required upon an entity's death. Provided as a ScriptableObject for easy assignment in the editor. Create instances via Assets -> Create -> Astra RPG Health / Death strategies / Do Nothing. MultipleOnDeathStrategy A death strategy that executes multiple death strategies in order. This allows combining multiple death behaviors without creating new strategy classes. Provided as a ScriptableObject for easy assignment in the editor. Create instances via Assets -> Create -> Astra RPG Health / Death strategies / Multiple. OnDeathStrategy Base strategy type for handling an entity's death. Derive from this class and implement Die(EntityHealth) to define custom death behavior."
  },
  "api/ElectricDrill.AstraRpgHealth.DefenseReductionFunctions.DefenseReductionFn.html": {
    "href": "api/ElectricDrill.AstraRpgHealth.DefenseReductionFunctions.DefenseReductionFn.html",
    "title": "Class DefenseReductionFn | Astra RPG Health",
    "summary": "Class DefenseReductionFn Namespace ElectricDrill.AstraRpgHealth.DefenseReductionFunctions Assembly com.electricdrill.astra-rpg-health.Runtime.dll Base type for defense reduction functions. Implementations compute a reduced defense value based on a piercing stat and the pierced defense stat. public abstract class DefenseReductionFn : ScriptableObject Inheritance object Object ScriptableObject DefenseReductionFn Derived FlatDefenseReductionFn LogDefenseReductionFn PercentageDefenseReductionFn Methods ReducedDef(long, long, Stat, bool) Compute the reduced defense value after applying a piercing stat. public abstract double ReducedDef(long piercingStatValue, long defensiveStatValue, Stat defensiveStat, bool applyClamp = true) Parameters piercingStatValue long The attacker's piercing stat value used to reduce defense. defensiveStatValue long The defender's original defense stat value to be reduced. defensiveStat Stat The defensive stat object used to clamp the result within its min/max bounds. applyClamp bool Whether to apply stat clamping to the result. Default true for normal gameplay; false for analysis/graphs. Returns double The reduced defense value (clamped if applyClamp is true)."
  },
  "api/ElectricDrill.AstraRpgHealth.DefenseReductionFunctions.DefenseReductionFunctions.FlatDefenseReductionFn.html": {
    "href": "api/ElectricDrill.AstraRpgHealth.DefenseReductionFunctions.DefenseReductionFunctions.FlatDefenseReductionFn.html",
    "title": "Class FlatDefenseReductionFn | Astra RPG Health",
    "summary": "Class FlatDefenseReductionFn Namespace ElectricDrill.AstraRpgHealth.DefenseReductionFunctions.DefenseReductionFunctions Assembly com.electricdrill.astra-rpg-health.Runtime.dll Reduces defense by subtracting a scaled amount of the piercing stat from the pierced defense. The result is clamped to the stat's min/max bounds. Create instances via Assets -> Create -> Astra RPG Health / Def Reduction Functions / Flat Def Reduction. [CreateAssetMenu(fileName = \"Flat Def Reduction Fn\", menuName = \"Astra RPG Health/Def Reduction Functions/Flat Def Reduction\")] public class FlatDefenseReductionFn : DefenseReductionFn Inheritance object Object ScriptableObject DefenseReductionFn FlatDefenseReductionFn Methods ReducedDef(long, long, Stat, bool) Subtracts (piercingStatValue * factor) from the pierced defense and optionally clamps the result to the stat's bounds. public override double ReducedDef(long piercingStatValue, long defensiveStatValue, Stat defensiveStat, bool applyClamp = true) Parameters piercingStatValue long The attacker's piercing stat value used to reduce defense. defensiveStatValue long The defender's original defense stat value to be reduced. defensiveStat Stat The defensive stat object used to clamp the result. applyClamp bool Whether to apply stat clamping to the result. Returns double The reduced defense value (clamped to stat's min/max bounds if applyClamp is true)."
  },
  "api/ElectricDrill.AstraRpgHealth.DefenseReductionFunctions.DefenseReductionFunctions.LogDefenseReductionFn.html": {
    "href": "api/ElectricDrill.AstraRpgHealth.DefenseReductionFunctions.DefenseReductionFunctions.LogDefenseReductionFn.html",
    "title": "Class LogDefenseReductionFn | Astra RPG Health",
    "summary": "Class LogDefenseReductionFn Namespace ElectricDrill.AstraRpgHealth.DefenseReductionFunctions.DefenseReductionFunctions Assembly com.electricdrill.astra-rpg-health.Runtime.dll Applies a logarithmic divisive reduction to defense to provide diminishing returns as piercing increases. Create instances via Assets -> Create -> Astra RPG Health / Def Reduction Functions / Log Def Reduction. [CreateAssetMenu(fileName = \"Log Def Reduction Fn\", menuName = \"Astra RPG Health/Def Reduction Functions/Log Def Reduction\")] public class LogDefenseReductionFn : DefenseReductionFn Inheritance object Object ScriptableObject DefenseReductionFn LogDefenseReductionFn Methods ReducedDef(long, long, Stat, bool) Reduces defense using a logarithmic divisive formula that provides diminishing returns. Formula: Reduced Defense = Defense * (BaseValue / (BaseValue + Log(1 + PiercingStat * ScaleFactor))) public override double ReducedDef(long piercingStatValue, long defensiveStatValue, Stat defensiveStat, bool applyClamp = true) Parameters piercingStatValue long The attacker's piercing stat value. defensiveStatValue long The defender's original defense stat value. defensiveStat Stat The defensive stat object used to clamp the result. applyClamp bool Whether to apply stat clamping to the result. Returns double The reduced defense value (clamped to stat's min/max bounds if applyClamp is true)"
  },
  "api/ElectricDrill.AstraRpgHealth.DefenseReductionFunctions.DefenseReductionFunctions.PercentageDefenseReductionFn.html": {
    "href": "api/ElectricDrill.AstraRpgHealth.DefenseReductionFunctions.DefenseReductionFunctions.PercentageDefenseReductionFn.html",
    "title": "Class PercentageDefenseReductionFn | Astra RPG Health",
    "summary": "Class PercentageDefenseReductionFn Namespace ElectricDrill.AstraRpgHealth.DefenseReductionFunctions.DefenseReductionFunctions Assembly com.electricdrill.astra-rpg-health.Runtime.dll Reduces defense by subtracting a percentage of the pierced defense equal to the piercing stat percentage. Example: piercingStatValue = 20 -> reduces defense by 20%. Create isntances via Assets -> Create -> Astra RPG Health / Def Reduction Functions / Log Def Reduction. [CreateAssetMenu(fileName = \"Percentage Def Reduction Fn\", menuName = \"Astra RPG Health/Def Reduction Functions/Percentage Def Reduction\")] public class PercentageDefenseReductionFn : DefenseReductionFn Inheritance object Object ScriptableObject DefenseReductionFn PercentageDefenseReductionFn Methods ReducedDef(long, long, Stat, bool) Apply percentage-based reduction to the pierced defense and optionally clamp the result to the stat's bounds. public override double ReducedDef(long piercingStatValue, long defensiveStatValue, Stat defensiveStat, bool applyClamp = true) Parameters piercingStatValue long Percentage to reduce (e.g. 25 means 25%). defensiveStatValue long Original defense stat. defensiveStat Stat The defensive stat object used to clamp the result. applyClamp bool Whether to apply stat clamping to the result. Returns double The reduced defense value (clamped to stat's min/max bounds if applyClamp is true)."
  },
  "api/ElectricDrill.AstraRpgHealth.DefenseReductionFunctions.DefenseReductionFunctions.html": {
    "href": "api/ElectricDrill.AstraRpgHealth.DefenseReductionFunctions.DefenseReductionFunctions.html",
    "title": "Namespace ElectricDrill.AstraRpgHealth.DefenseReductionFunctions.DefenseReductionFunctions | Astra RPG Health",
    "summary": "Namespace ElectricDrill.AstraRpgHealth.DefenseReductionFunctions.DefenseReductionFunctions Classes FlatDefenseReductionFn Reduces defense by subtracting a scaled amount of the piercing stat from the pierced defense. The result is clamped to the stat's min/max bounds. Create instances via Assets -> Create -> Astra RPG Health / Def Reduction Functions / Flat Def Reduction. LogDefenseReductionFn Applies a logarithmic divisive reduction to defense to provide diminishing returns as piercing increases. Create instances via Assets -> Create -> Astra RPG Health / Def Reduction Functions / Log Def Reduction. PercentageDefenseReductionFn Reduces defense by subtracting a percentage of the pierced defense equal to the piercing stat percentage. Example: piercingStatValue = 20 -> reduces defense by 20%. Create isntances via Assets -> Create -> Astra RPG Health / Def Reduction Functions / Log Def Reduction."
  },
  "api/ElectricDrill.AstraRpgHealth.DefenseReductionFunctions.html": {
    "href": "api/ElectricDrill.AstraRpgHealth.DefenseReductionFunctions.html",
    "title": "Namespace ElectricDrill.AstraRpgHealth.DefenseReductionFunctions | Astra RPG Health",
    "summary": "Namespace ElectricDrill.AstraRpgHealth.DefenseReductionFunctions Classes DefenseReductionFn Base type for defense reduction functions. Implementations compute a reduced defense value based on a piercing stat and the pierced defense stat."
  },
  "api/ElectricDrill.AstraRpgHealth.EntityHealth.HpBehaviourOnMaxHpDecrease.html": {
    "href": "api/ElectricDrill.AstraRpgHealth.EntityHealth.HpBehaviourOnMaxHpDecrease.html",
    "title": "Enum EntityHealth.HpBehaviourOnMaxHpDecrease | Astra RPG Health",
    "summary": "Enum EntityHealth.HpBehaviourOnMaxHpDecrease Namespace ElectricDrill.AstraRpgHealth Assembly com.electricdrill.astra-rpg-health.Runtime.dll public enum EntityHealth.HpBehaviourOnMaxHpDecrease Fields RemoveHealthAnyway = 3 RemoveHealthUpTo1 = 2 RemoveHealthUpToMaxHp = 0 RemoveHealthUpToMaxHpAndConvertRemovedToBarrier = 1"
  },
  "api/ElectricDrill.AstraRpgHealth.EntityHealth.HpBehaviourOnMaxHpIncrease.html": {
    "href": "api/ElectricDrill.AstraRpgHealth.EntityHealth.HpBehaviourOnMaxHpIncrease.html",
    "title": "Enum EntityHealth.HpBehaviourOnMaxHpIncrease | Astra RPG Health",
    "summary": "Enum EntityHealth.HpBehaviourOnMaxHpIncrease Namespace ElectricDrill.AstraRpgHealth Assembly com.electricdrill.astra-rpg-health.Runtime.dll public enum EntityHealth.HpBehaviourOnMaxHpIncrease Fields AddHealthAndConvertExcessToBarrier = 2 AddHealthUpToMaxHp = 1 None = 0"
  },
  "api/ElectricDrill.AstraRpgHealth.EntityHealth.html": {
    "href": "api/ElectricDrill.AstraRpgHealth.EntityHealth.html",
    "title": "Class EntityHealth | Astra RPG Health",
    "summary": "Class EntityHealth Namespace ElectricDrill.AstraRpgHealth Assembly com.electricdrill.astra-rpg-health.Runtime.dll Manages the health, damage, and healing mechanics for an entity. Handles damage calculation, health regeneration, barriers (temporary HP), and death events. [RequireComponent(typeof(EntityCore))] public class EntityHealth : MonoBehaviour, IDamageable, IHealable, IResurrectable Inheritance object Object Component Behaviour MonoBehaviour EntityHealth Implements IDamageable IHealable IResurrectable Properties Barrier Gets the current barrier points (temporary HP) of the entity. public long Barrier { get; } Property Value long Class Gets or sets the EntityClass component associated with this entity. public EntityClass Class { get; set; } Property Value EntityClass EntityAttributes Gets or sets the EntityAttributes component associated with this entity. public EntityAttributes EntityAttributes { get; set; } Property Value EntityAttributes EntityCore Gets or sets the EntityCore component associated with this entity. public EntityCore EntityCore { get; set; } Property Value EntityCore EntityStats Gets or sets the EntityStats component associated with this entity. public EntityStats EntityStats { get; set; } Property Value EntityStats HealthCanBeNegative Gets or sets whether the entity's health can go below zero. When set to true, a death threshold must be defined. public bool HealthCanBeNegative { get; set; } Property Value bool Hp Gets the current health points of the entity. public long Hp { get; } Property Value long IsImmune Gets or sets whether the entity is immune to all damage. public bool IsImmune { get; set; } Property Value bool MaxHp Gets the maximum health points of the entity. public long MaxHp { get; } Property Value long OverrideOnDeathStrategy Gets or sets the override strategy for handling entity death. This strategy takes precedence over the default strategy defined in the config. If null, the default strategy from the config will be used. public OnDeathStrategy OverrideOnDeathStrategy { get; set; } Property Value OnDeathStrategy Methods AddMaxHpFlatModifier(long, HpBehaviourOnMaxHpIncrease, HpBehaviourOnMaxHpDecrease) Adds a flat modifier to the entity's maximum health. public void AddMaxHpFlatModifier(long amount, EntityHealth.HpBehaviourOnMaxHpIncrease onMaxHpIncrease = HpBehaviourOnMaxHpIncrease.None, EntityHealth.HpBehaviourOnMaxHpDecrease onMaxHpDecrease = HpBehaviourOnMaxHpDecrease.RemoveHealthUpToMaxHp) Parameters amount long The amount to add to the flat modifier. Can be negative. onMaxHpIncrease EntityHealth.HpBehaviourOnMaxHpIncrease Behavior to apply when max HP increases. onMaxHpDecrease EntityHealth.HpBehaviourOnMaxHpDecrease Behavior to apply when max HP decreases. AddMaxHpPercentageModifier(Percentage, HpBehaviourOnMaxHpIncrease, HpBehaviourOnMaxHpDecrease) Adds a percentage modifier to the entity's maximum health. public void AddMaxHpPercentageModifier(Percentage amount, EntityHealth.HpBehaviourOnMaxHpIncrease onMaxHpIncrease = HpBehaviourOnMaxHpIncrease.None, EntityHealth.HpBehaviourOnMaxHpDecrease onMaxHpDecrease = HpBehaviourOnMaxHpDecrease.RemoveHealthUpToMaxHp) Parameters amount Percentage The percentage to add to the modifier. onMaxHpIncrease EntityHealth.HpBehaviourOnMaxHpIncrease Behavior to apply when max HP increases. onMaxHpDecrease EntityHealth.HpBehaviourOnMaxHpDecrease Behavior to apply when max HP decreases. AddMaxHpScaling(StatsScalingComponent, HpBehaviourOnMaxHpIncrease, HpBehaviourOnMaxHpDecrease) Adds a stats-based scaling component that dynamically affects maximum health. Subscribes to stat changes if this is the first scaling added. public void AddMaxHpScaling(StatsScalingComponent scaling, EntityHealth.HpBehaviourOnMaxHpIncrease onMaxHpIncrease = HpBehaviourOnMaxHpIncrease.None, EntityHealth.HpBehaviourOnMaxHpDecrease onMaxHpDecrease = HpBehaviourOnMaxHpDecrease.RemoveHealthUpToMaxHp) Parameters scaling StatsScalingComponent The scaling component to add. onMaxHpIncrease EntityHealth.HpBehaviourOnMaxHpIncrease Behavior to apply when max HP increases because of the scaling. onMaxHpDecrease EntityHealth.HpBehaviourOnMaxHpDecrease Behavior to apply when max HP decreases because of the scaling. CalculateReducedDmg(long, long, DefenseReductionFn, long, Stat, DamageReductionFn, bool) Calculates reduced damage based on piercing and defensive stats using reduction functions. public static long CalculateReducedDmg(long amount, long piercingStatValue, DefenseReductionFn defenseReductionFn, long defensiveStatValue, Stat defensiveStat, DamageReductionFn damageReductionFn, bool applyClamp = true) Parameters amount long The base damage amount. piercingStatValue long The attacker's piercing stat value. defenseReductionFn DefenseReductionFn Function to calculate defense reduction (can be null). defensiveStatValue long The defender's defensive stat value. defensiveStat Stat The defensive stat object (can be null if defenseReductionFn is null). damageReductionFn DamageReductionFn Function to calculate damage reduction (can be null). applyClamp bool Whether to apply stat clamping in defense reduction. Default true for gameplay; false for analysis. Returns long The reduced damage amount after applying all reduction calculations. ClearMaxHpScalings(HpBehaviourOnMaxHpIncrease, HpBehaviourOnMaxHpDecrease) Removes all stats-based scaling components from maximum health calculations. public void ClearMaxHpScalings(EntityHealth.HpBehaviourOnMaxHpIncrease onMaxHpIncrease = HpBehaviourOnMaxHpIncrease.None, EntityHealth.HpBehaviourOnMaxHpDecrease onMaxHpDecrease = HpBehaviourOnMaxHpDecrease.RemoveHealthUpToMaxHp) Parameters onMaxHpIncrease EntityHealth.HpBehaviourOnMaxHpIncrease onMaxHpDecrease EntityHealth.HpBehaviourOnMaxHpDecrease Heal(PreHealInfo) Heals the entity by the specified amount, applying critical multipliers and heal modifiers. The actual health gained may be less than the heal amount if the entity is at or near maximum health. Throws DeadEntityException if the entity is dead. public ReceivedHealInfo Heal(PreHealInfo info) Parameters info PreHealInfo The pre-heal information including amount, source, and healer. Returns ReceivedHealInfo Information about the heal received including the actual health gained. Exceptions DeadEntityException Thrown when attempting to heal a dead entity. IsAlive() Checks if the entity's current health is above the death threshold. public bool IsAlive() Returns bool true if current health is > death threshold, false otherwise IsDead() Checks if the entity's current health is at or below the death threshold. Returns the cached death state for performance. public bool IsDead() Returns bool true if current health is <= death threshold, false otherwise ManualHealthRegenerationTick() Method to be called to trigger manual health regeneration (e.g., if you are using a turn-based system, call this method at the start/end of each turn). public void ManualHealthRegenerationTick() RemoveMaxHpScaling(StatsScalingComponent, HpBehaviourOnMaxHpIncrease, HpBehaviourOnMaxHpDecrease) Removes a previously added stats-based scaling component from maximum health calculations. Unsubscribes from stat changes if no scalings remain. public void RemoveMaxHpScaling(StatsScalingComponent scaling, EntityHealth.HpBehaviourOnMaxHpIncrease onMaxHpIncrease = HpBehaviourOnMaxHpIncrease.None, EntityHealth.HpBehaviourOnMaxHpDecrease onMaxHpDecrease = HpBehaviourOnMaxHpDecrease.RemoveHealthUpToMaxHp) Parameters scaling StatsScalingComponent The scaling component to remove. onMaxHpIncrease EntityHealth.HpBehaviourOnMaxHpIncrease Behavior to apply when max HP increases because of the scaling removal. onMaxHpDecrease EntityHealth.HpBehaviourOnMaxHpDecrease Behavior to apply when max HP decreases because of the scaling removal. Resurrect(Percentage) Resurrects the entity with a percentage of maximum health using the default resurrection source from config. Throws InvalidOperationException if the entity is already alive. public void Resurrect(Percentage withHpPercent) Parameters withHpPercent Percentage The percentage of maximum health to restore on resurrection. Exceptions InvalidOperationException Thrown when attempting to resurrect an entity that is already alive. Resurrect(Percentage, HealSource) Resurrects the entity with a percentage of maximum health. Throws InvalidOperationException if the entity is already alive. public void Resurrect(Percentage withHpPercent, HealSource healSource) Parameters withHpPercent Percentage The percentage of maximum health to restore on resurrection. healSource HealSource The heal source associated with the resurrection. Exceptions InvalidOperationException Thrown when attempting to resurrect an entity that is already alive. Resurrect(long) Resurrects the entity with a specific amount of health using the default resurrection source from config. Throws InvalidOperationException if the entity is already alive. public void Resurrect(long withHp) Parameters withHp long The amount of health to restore on resurrection. Exceptions InvalidOperationException Thrown when attempting to resurrect an entity that is already alive. Resurrect(long, HealSource) Resurrects the entity with a specific amount of health. Throws InvalidOperationException if the entity is already alive. public void Resurrect(long withHp, HealSource healSource) Parameters withHp long The amount of health to restore on resurrection. healSource HealSource The heal source associated with the resurrection. Exceptions InvalidOperationException Thrown when attempting to resurrect an entity that is already alive. SetHpToMax() Sets the entity's current health to its maximum health value. Throws DeadEntityException if the entity is dead. public void SetHpToMax() Exceptions DeadEntityException Thrown when attempting to set HP to max on a dead entity. SetupMaxHp(HpBehaviourOnMaxHpIncrease, HpBehaviourOnMaxHpDecrease) Recalculates and updates the entity's maximum health based on base value, modifiers, and scaling. Raises the max health changed event if the value differs from the previous maximum. If the entity is dead, only recalculates max HP and raises events without adjusting current HP. Behavior to apply when max HP increases. Behavior to apply when max HP decreases. public void SetupMaxHp(EntityHealth.HpBehaviourOnMaxHpIncrease onMaxHpIncrease, EntityHealth.HpBehaviourOnMaxHpDecrease onMaxHpDecrease = HpBehaviourOnMaxHpDecrease.RemoveHealthUpToMaxHp) Parameters onMaxHpIncrease EntityHealth.HpBehaviourOnMaxHpIncrease onMaxHpDecrease EntityHealth.HpBehaviourOnMaxHpDecrease TakeDamage(PreDamageInfo) Applies damage to the entity through the damage calculation pipeline. This is the primary method for dealing damage in the Astra RPG Health system. Execution Order: Death State Check: If the entity is already dead, the damage is marked as prevented with EntityDead reason and returned immediately. Dead entities cannot take damage. Pre-Damage Event: Raises the PreDamageGameEvent to notify listeners of incoming damage. This allows systems to react before any damage calculations occur. DamageInfo Creation: Converts the PreDamageInfo into a DamageInfo object that will track the damage through the calculation pipeline. Immunity Check: If the entity is immune (IsImmune is true), the damage is marked as prevented with EntityImmune reason. This happens before the pipeline to short-circuit processing. Damage Calculation Pipeline: If damage is not already prevented, the configured DamageCalculationStrategy processes the damage. The pipeline can apply: Damage reduction based on defensive stats Barrier consumption (temporary HP absorption) Critical hit calculations General damage and/or damage type and damage source modifiers Custom pipeline stages defined in the strategy The pipeline can also mark damage as prevented for various reasons. Prevention Check: If the damage was prevented (either by immunity or during the pipeline): Creates a DamageResolution.Prevented result with all prevention reasons Raises the DamageResolutionGameEvent Returns immediately without affecting health Health Reduction: If damage was not prevented, the final calculated damage amount is subtracted from the entity's current health via RemoveHealth(). This may trigger the LostHealthGameEvent. Damage Resolution Event: Raises the DamageResolutionGameEvent with the applied damage information. This allows systems to react to successful damage (e.g., lifesteal, on-hit effects). Death Check: If the entity's health is now at or below the death threshold: Raises the EntityDiedGameEvent with this EntityHealth and the DamageResolution Executes the OnDeathStrategy (either the entity's override or the config default) The death strategy handles the actual death behavior (e.g., destroy, return ot the object pool, disable, ragdoll) Return: Returns a DamageResolution.Applied result containing all damage information for the caller to process if needed. Strategy Selection: The method uses the first available DamageCalculationStrategy in this priority order: OverrideDamageCalculationStrategy (if set on this EntityHealth) CustomDamageCalculationStrategy (if set on this EntityHealth) DefaultDamageCalculationStrategy (from the AstraRpgHealthConfig) public DamageResolution TakeDamage(PreDamageInfo preDamage) Parameters preDamage PreDamageInfo The pre-damage information including base amount, damage type, dealer entity, and additional context. This is used by the damage calculation pipeline to compute the final damage to apply. Returns DamageResolution A DamageResolution indicating whether damage was applied or prevented. If prevented, includes the reasons for prevention. If applied, includes the final damage amounts and calculation details."
  },
  "api/ElectricDrill.AstraRpgHealth.Events.DamageResolutionGameEvent.html": {
    "href": "api/ElectricDrill.AstraRpgHealth.Events.DamageResolutionGameEvent.html",
    "title": "Class DamageResolutionGameEvent | Astra RPG Health",
    "summary": "Class DamageResolutionGameEvent Namespace ElectricDrill.AstraRpgHealth.Events Assembly com.electricdrill.astra-rpg-health.Runtime.dll Used to notify whether a damage was applied or prevented. [CreateAssetMenu(fileName = \"DamageResolution Game Event\", menuName = \"Astra RPG Health/Events/Generated (Damage)/DamageResolution\")] public class DamageResolutionGameEvent : GameEventGeneric1<DamageResolution>, IRaisable<DamageResolution> Inheritance object Object ScriptableObject GameEventGeneric1<DamageResolution> DamageResolutionGameEvent Implements IRaisable<DamageResolution> Inherited Members GameEventGeneric1<DamageResolution>.OnEventRaised GameEventGeneric1<DamageResolution>.Raise(DamageResolution) GameEventGeneric1<DamageResolution>.RegisterListener(GameEventListenerGeneric1<DamageResolution>) GameEventGeneric1<DamageResolution>.UnregisterListener(GameEventListenerGeneric1<DamageResolution>)"
  },
  "api/ElectricDrill.AstraRpgHealth.Events.DamageResolutionGameEventListener.html": {
    "href": "api/ElectricDrill.AstraRpgHealth.Events.DamageResolutionGameEventListener.html",
    "title": "Class DamageResolutionGameEventListener | Astra RPG Health",
    "summary": "Class DamageResolutionGameEventListener Namespace ElectricDrill.AstraRpgHealth.Events Assembly com.electricdrill.astra-rpg-health.Runtime.dll Used to notify whether a damage was applied or prevented. public class DamageResolutionGameEventListener : GameEventListenerGeneric1<DamageResolution> Inheritance object Object Component Behaviour MonoBehaviour GameEventListenerGeneric1<DamageResolution> DamageResolutionGameEventListener Inherited Members GameEventListenerGeneric1<DamageResolution>._event GameEventListenerGeneric1<DamageResolution>._response GameEventListenerGeneric1<DamageResolution>.OnEventRaised(DamageResolution)"
  },
  "api/ElectricDrill.AstraRpgHealth.Events.EntityDiedGameEvent.html": {
    "href": "api/ElectricDrill.AstraRpgHealth.Events.EntityDiedGameEvent.html",
    "title": "Class EntityDiedGameEvent | Astra RPG Health",
    "summary": "Class EntityDiedGameEvent Namespace ElectricDrill.AstraRpgHealth.Events Assembly com.electricdrill.astra-rpg-health.Runtime.dll The entity died. [CreateAssetMenu(fileName = \"EntityDied Game Event\", menuName = \"Astra RPG Health/Events/Generated (Health)/EntityDied\")] public class EntityDiedGameEvent : GameEventGeneric2<EntityHealth, DamageResolution>, IRaisable<EntityHealth, DamageResolution> Inheritance object Object ScriptableObject GameEventGeneric2<EntityHealth, DamageResolution> EntityDiedGameEvent Implements IRaisable<EntityHealth, DamageResolution> Inherited Members GameEventGeneric2<EntityHealth, DamageResolution>.OnEventRaised GameEventGeneric2<EntityHealth, DamageResolution>.Raise(EntityHealth, DamageResolution) GameEventGeneric2<EntityHealth, DamageResolution>.RegisterListener(GameEventListenerGeneric2<EntityHealth, DamageResolution>) GameEventGeneric2<EntityHealth, DamageResolution>.UnregisterListener(GameEventListenerGeneric2<EntityHealth, DamageResolution>)"
  },
  "api/ElectricDrill.AstraRpgHealth.Events.EntityDiedGameEventListener.html": {
    "href": "api/ElectricDrill.AstraRpgHealth.Events.EntityDiedGameEventListener.html",
    "title": "Class EntityDiedGameEventListener | Astra RPG Health",
    "summary": "Class EntityDiedGameEventListener Namespace ElectricDrill.AstraRpgHealth.Events Assembly com.electricdrill.astra-rpg-health.Runtime.dll The entity died. public class EntityDiedGameEventListener : GameEventListenerGeneric2<EntityHealth, DamageResolution> Inheritance object Object Component Behaviour MonoBehaviour GameEventListenerGeneric2<EntityHealth, DamageResolution> EntityDiedGameEventListener Inherited Members GameEventListenerGeneric2<EntityHealth, DamageResolution>._event GameEventListenerGeneric2<EntityHealth, DamageResolution>._response GameEventListenerGeneric2<EntityHealth, DamageResolution>.OnEventRaised(EntityHealth, DamageResolution)"
  },
  "api/ElectricDrill.AstraRpgHealth.Events.EntityGainedHealthGameEvent.html": {
    "href": "api/ElectricDrill.AstraRpgHealth.Events.EntityGainedHealthGameEvent.html",
    "title": "Class EntityGainedHealthGameEvent | Astra RPG Health",
    "summary": "Class EntityGainedHealthGameEvent Namespace ElectricDrill.AstraRpgHealth.Events Assembly com.electricdrill.astra-rpg-health.Runtime.dll The entity gained some health. [CreateAssetMenu(fileName = \"EntityGainedHealth Game Event\", menuName = \"Astra RPG Health/Events/Generated (Health)/EntityGainedHealth\")] public class EntityGainedHealthGameEvent : GameEventGeneric2<EntityHealth, long>, IRaisable<EntityHealth, long> Inheritance object Object ScriptableObject GameEventGeneric2<EntityHealth, long> EntityGainedHealthGameEvent Implements IRaisable<EntityHealth, long> Inherited Members GameEventGeneric2<EntityHealth, long>.OnEventRaised GameEventGeneric2<EntityHealth, long>.Raise(EntityHealth, long) GameEventGeneric2<EntityHealth, long>.RegisterListener(GameEventListenerGeneric2<EntityHealth, long>) GameEventGeneric2<EntityHealth, long>.UnregisterListener(GameEventListenerGeneric2<EntityHealth, long>)"
  },
  "api/ElectricDrill.AstraRpgHealth.Events.EntityGainedHealthGameEventListener.html": {
    "href": "api/ElectricDrill.AstraRpgHealth.Events.EntityGainedHealthGameEventListener.html",
    "title": "Class EntityGainedHealthGameEventListener | Astra RPG Health",
    "summary": "Class EntityGainedHealthGameEventListener Namespace ElectricDrill.AstraRpgHealth.Events Assembly com.electricdrill.astra-rpg-health.Runtime.dll The entity gained some health. public class EntityGainedHealthGameEventListener : GameEventListenerGeneric2<EntityHealth, long> Inheritance object Object Component Behaviour MonoBehaviour GameEventListenerGeneric2<EntityHealth, long> EntityGainedHealthGameEventListener Inherited Members GameEventListenerGeneric2<EntityHealth, long>._event GameEventListenerGeneric2<EntityHealth, long>._response GameEventListenerGeneric2<EntityHealth, long>.OnEventRaised(EntityHealth, long)"
  },
  "api/ElectricDrill.AstraRpgHealth.Events.EntityHealedGameEvent.html": {
    "href": "api/ElectricDrill.AstraRpgHealth.Events.EntityHealedGameEvent.html",
    "title": "Class EntityHealedGameEvent | Astra RPG Health",
    "summary": "Class EntityHealedGameEvent Namespace ElectricDrill.AstraRpgHealth.Events Assembly com.electricdrill.astra-rpg-health.Runtime.dll The entity received an healing. [CreateAssetMenu(fileName = \"EntityHealed Game Event\", menuName = \"Astra RPG Health/Events/Generated (Health)/EntityHealed\")] public class EntityHealedGameEvent : GameEventGeneric1<ReceivedHealInfo>, IRaisable<ReceivedHealInfo> Inheritance object Object ScriptableObject GameEventGeneric1<ReceivedHealInfo> EntityHealedGameEvent Implements IRaisable<ReceivedHealInfo> Inherited Members GameEventGeneric1<ReceivedHealInfo>.OnEventRaised GameEventGeneric1<ReceivedHealInfo>.Raise(ReceivedHealInfo) GameEventGeneric1<ReceivedHealInfo>.RegisterListener(GameEventListenerGeneric1<ReceivedHealInfo>) GameEventGeneric1<ReceivedHealInfo>.UnregisterListener(GameEventListenerGeneric1<ReceivedHealInfo>)"
  },
  "api/ElectricDrill.AstraRpgHealth.Events.EntityHealedGameEventListener.html": {
    "href": "api/ElectricDrill.AstraRpgHealth.Events.EntityHealedGameEventListener.html",
    "title": "Class EntityHealedGameEventListener | Astra RPG Health",
    "summary": "Class EntityHealedGameEventListener Namespace ElectricDrill.AstraRpgHealth.Events Assembly com.electricdrill.astra-rpg-health.Runtime.dll The entity received an healing. public class EntityHealedGameEventListener : GameEventListenerGeneric1<ReceivedHealInfo> Inheritance object Object Component Behaviour MonoBehaviour GameEventListenerGeneric1<ReceivedHealInfo> EntityHealedGameEventListener Inherited Members GameEventListenerGeneric1<ReceivedHealInfo>._event GameEventListenerGeneric1<ReceivedHealInfo>._response GameEventListenerGeneric1<ReceivedHealInfo>.OnEventRaised(ReceivedHealInfo)"
  },
  "api/ElectricDrill.AstraRpgHealth.Events.EntityLostHealthGameEvent.html": {
    "href": "api/ElectricDrill.AstraRpgHealth.Events.EntityLostHealthGameEvent.html",
    "title": "Class EntityLostHealthGameEvent | Astra RPG Health",
    "summary": "Class EntityLostHealthGameEvent Namespace ElectricDrill.AstraRpgHealth.Events Assembly com.electricdrill.astra-rpg-health.Runtime.dll The entity lost some health. [CreateAssetMenu(fileName = \"EntityLostHealth Game Event\", menuName = \"Astra RPG Health/Events/Generated (Health)/EntityLostHealth\")] public class EntityLostHealthGameEvent : GameEventGeneric2<EntityHealth, long>, IRaisable<EntityHealth, long> Inheritance object Object ScriptableObject GameEventGeneric2<EntityHealth, long> EntityLostHealthGameEvent Implements IRaisable<EntityHealth, long> Inherited Members GameEventGeneric2<EntityHealth, long>.OnEventRaised GameEventGeneric2<EntityHealth, long>.Raise(EntityHealth, long) GameEventGeneric2<EntityHealth, long>.RegisterListener(GameEventListenerGeneric2<EntityHealth, long>) GameEventGeneric2<EntityHealth, long>.UnregisterListener(GameEventListenerGeneric2<EntityHealth, long>)"
  },
  "api/ElectricDrill.AstraRpgHealth.Events.EntityLostHealthGameEventListener.html": {
    "href": "api/ElectricDrill.AstraRpgHealth.Events.EntityLostHealthGameEventListener.html",
    "title": "Class EntityLostHealthGameEventListener | Astra RPG Health",
    "summary": "Class EntityLostHealthGameEventListener Namespace ElectricDrill.AstraRpgHealth.Events Assembly com.electricdrill.astra-rpg-health.Runtime.dll The entity lost some health. public class EntityLostHealthGameEventListener : GameEventListenerGeneric2<EntityHealth, long> Inheritance object Object Component Behaviour MonoBehaviour GameEventListenerGeneric2<EntityHealth, long> EntityLostHealthGameEventListener Inherited Members GameEventListenerGeneric2<EntityHealth, long>._event GameEventListenerGeneric2<EntityHealth, long>._response GameEventListenerGeneric2<EntityHealth, long>.OnEventRaised(EntityHealth, long)"
  },
  "api/ElectricDrill.AstraRpgHealth.Events.EntityMaxHealthChangedGameEvent.html": {
    "href": "api/ElectricDrill.AstraRpgHealth.Events.EntityMaxHealthChangedGameEvent.html",
    "title": "Class EntityMaxHealthChangedGameEvent | Astra RPG Health",
    "summary": "Class EntityMaxHealthChangedGameEvent Namespace ElectricDrill.AstraRpgHealth.Events Assembly com.electricdrill.astra-rpg-health.Runtime.dll The entity whose Max HP changed, the new Max HP, and the old Max HP. [CreateAssetMenu(fileName = \"EntityMaxHealthChanged Game Event\", menuName = \"Astra RPG Health/Events/Generated (Health)/EntityMaxHealthChanged\")] public class EntityMaxHealthChangedGameEvent : GameEventGeneric3<EntityHealth, long, long>, IRaisable<EntityHealth, long, long> Inheritance object Object ScriptableObject GameEventGeneric3<EntityHealth, long, long> EntityMaxHealthChangedGameEvent Implements IRaisable<EntityHealth, long, long> Inherited Members GameEventGeneric3<EntityHealth, long, long>.OnEventRaised GameEventGeneric3<EntityHealth, long, long>.Raise(EntityHealth, long, long) GameEventGeneric3<EntityHealth, long, long>.RegisterListener(GameEventListenerGeneric3<EntityHealth, long, long>) GameEventGeneric3<EntityHealth, long, long>.UnregisterListener(GameEventListenerGeneric3<EntityHealth, long, long>)"
  },
  "api/ElectricDrill.AstraRpgHealth.Events.EntityMaxHealthChangedGameEventListener.html": {
    "href": "api/ElectricDrill.AstraRpgHealth.Events.EntityMaxHealthChangedGameEventListener.html",
    "title": "Class EntityMaxHealthChangedGameEventListener | Astra RPG Health",
    "summary": "Class EntityMaxHealthChangedGameEventListener Namespace ElectricDrill.AstraRpgHealth.Events Assembly com.electricdrill.astra-rpg-health.Runtime.dll The entity whose Max HP changed, the new Max HP, and the old Max HP. public class EntityMaxHealthChangedGameEventListener : GameEventListenerGeneric3<EntityHealth, long, long> Inheritance object Object Component Behaviour MonoBehaviour GameEventListenerGeneric3<EntityHealth, long, long> EntityMaxHealthChangedGameEventListener Inherited Members GameEventListenerGeneric3<EntityHealth, long, long>._event GameEventListenerGeneric3<EntityHealth, long, long>._response GameEventListenerGeneric3<EntityHealth, long, long>.OnEventRaised(EntityHealth, long, long)"
  },
  "api/ElectricDrill.AstraRpgHealth.Events.EntityResurrectedGameEvent.html": {
    "href": "api/ElectricDrill.AstraRpgHealth.Events.EntityResurrectedGameEvent.html",
    "title": "Class EntityResurrectedGameEvent | Astra RPG Health",
    "summary": "Class EntityResurrectedGameEvent Namespace ElectricDrill.AstraRpgHealth.Events Assembly com.electricdrill.astra-rpg-health.Runtime.dll The entity resurrected with the specified amount of health. [CreateAssetMenu(fileName = \"EntityResurrected Game Event\", menuName = \"Astra RPG Health/Events/Generated (Health)/EntityResurrected\")] public class EntityResurrectedGameEvent : GameEventGeneric2<EntityHealth, ResurrectionInfo>, IRaisable<EntityHealth, ResurrectionInfo> Inheritance object Object ScriptableObject GameEventGeneric2<EntityHealth, ResurrectionInfo> EntityResurrectedGameEvent Implements IRaisable<EntityHealth, ResurrectionInfo> Inherited Members GameEventGeneric2<EntityHealth, ResurrectionInfo>.OnEventRaised GameEventGeneric2<EntityHealth, ResurrectionInfo>.Raise(EntityHealth, ResurrectionInfo) GameEventGeneric2<EntityHealth, ResurrectionInfo>.RegisterListener(GameEventListenerGeneric2<EntityHealth, ResurrectionInfo>) GameEventGeneric2<EntityHealth, ResurrectionInfo>.UnregisterListener(GameEventListenerGeneric2<EntityHealth, ResurrectionInfo>)"
  },
  "api/ElectricDrill.AstraRpgHealth.Events.EntityResurrectedGameEventListener.html": {
    "href": "api/ElectricDrill.AstraRpgHealth.Events.EntityResurrectedGameEventListener.html",
    "title": "Class EntityResurrectedGameEventListener | Astra RPG Health",
    "summary": "Class EntityResurrectedGameEventListener Namespace ElectricDrill.AstraRpgHealth.Events Assembly com.electricdrill.astra-rpg-health.Runtime.dll The entity resurrected with the specified amount of health. public class EntityResurrectedGameEventListener : GameEventListenerGeneric2<EntityHealth, ResurrectionInfo> Inheritance object Object Component Behaviour MonoBehaviour GameEventListenerGeneric2<EntityHealth, ResurrectionInfo> EntityResurrectedGameEventListener Inherited Members GameEventListenerGeneric2<EntityHealth, ResurrectionInfo>._event GameEventListenerGeneric2<EntityHealth, ResurrectionInfo>._response GameEventListenerGeneric2<EntityHealth, ResurrectionInfo>.OnEventRaised(EntityHealth, ResurrectionInfo)"
  },
  "api/ElectricDrill.AstraRpgHealth.Events.PreDmgGameEvent.html": {
    "href": "api/ElectricDrill.AstraRpgHealth.Events.PreDmgGameEvent.html",
    "title": "Class PreDmgGameEvent | Astra RPG Health",
    "summary": "Class PreDmgGameEvent Namespace ElectricDrill.AstraRpgHealth.Events Assembly com.electricdrill.astra-rpg-health.Runtime.dll [CreateAssetMenu(fileName = \"PreDmg Game Event\", menuName = \"Astra RPG Health/Events/Generated (Damage)/PreDmg\")] public class PreDmgGameEvent : GameEventGeneric1<PreDamageInfo>, IRaisable<PreDamageInfo> Inheritance object Object ScriptableObject GameEventGeneric1<PreDamageInfo> PreDmgGameEvent Implements IRaisable<PreDamageInfo> Inherited Members GameEventGeneric1<PreDamageInfo>.OnEventRaised GameEventGeneric1<PreDamageInfo>.Raise(PreDamageInfo) GameEventGeneric1<PreDamageInfo>.RegisterListener(GameEventListenerGeneric1<PreDamageInfo>) GameEventGeneric1<PreDamageInfo>.UnregisterListener(GameEventListenerGeneric1<PreDamageInfo>)"
  },
  "api/ElectricDrill.AstraRpgHealth.Events.PreDmgGameEventListener.html": {
    "href": "api/ElectricDrill.AstraRpgHealth.Events.PreDmgGameEventListener.html",
    "title": "Class PreDmgGameEventListener | Astra RPG Health",
    "summary": "Class PreDmgGameEventListener Namespace ElectricDrill.AstraRpgHealth.Events Assembly com.electricdrill.astra-rpg-health.Runtime.dll public class PreDmgGameEventListener : GameEventListenerGeneric1<PreDamageInfo> Inheritance object Object Component Behaviour MonoBehaviour GameEventListenerGeneric1<PreDamageInfo> PreDmgGameEventListener Inherited Members GameEventListenerGeneric1<PreDamageInfo>._event GameEventListenerGeneric1<PreDamageInfo>._response GameEventListenerGeneric1<PreDamageInfo>.OnEventRaised(PreDamageInfo)"
  },
  "api/ElectricDrill.AstraRpgHealth.Events.PreHealGameEvent.html": {
    "href": "api/ElectricDrill.AstraRpgHealth.Events.PreHealGameEvent.html",
    "title": "Class PreHealGameEvent | Astra RPG Health",
    "summary": "Class PreHealGameEvent Namespace ElectricDrill.AstraRpgHealth.Events Assembly com.electricdrill.astra-rpg-health.Runtime.dll THe entity is about to be healed. [CreateAssetMenu(fileName = \"PreHeal Game Event\", menuName = \"Astra RPG Health/Events/Generated (Health)/PreHeal\")] public class PreHealGameEvent : GameEventGeneric2<PreHealInfo, EntityCore>, IRaisable<PreHealInfo, EntityCore> Inheritance object Object ScriptableObject GameEventGeneric2<PreHealInfo, EntityCore> PreHealGameEvent Implements IRaisable<PreHealInfo, EntityCore> Inherited Members GameEventGeneric2<PreHealInfo, EntityCore>.OnEventRaised GameEventGeneric2<PreHealInfo, EntityCore>.Raise(PreHealInfo, EntityCore) GameEventGeneric2<PreHealInfo, EntityCore>.RegisterListener(GameEventListenerGeneric2<PreHealInfo, EntityCore>) GameEventGeneric2<PreHealInfo, EntityCore>.UnregisterListener(GameEventListenerGeneric2<PreHealInfo, EntityCore>)"
  },
  "api/ElectricDrill.AstraRpgHealth.Events.PreHealGameEventListener.html": {
    "href": "api/ElectricDrill.AstraRpgHealth.Events.PreHealGameEventListener.html",
    "title": "Class PreHealGameEventListener | Astra RPG Health",
    "summary": "Class PreHealGameEventListener Namespace ElectricDrill.AstraRpgHealth.Events Assembly com.electricdrill.astra-rpg-health.Runtime.dll THe entity is about to be healed. public class PreHealGameEventListener : GameEventListenerGeneric2<PreHealInfo, EntityCore> Inheritance object Object Component Behaviour MonoBehaviour GameEventListenerGeneric2<PreHealInfo, EntityCore> PreHealGameEventListener Inherited Members GameEventListenerGeneric2<PreHealInfo, EntityCore>._event GameEventListenerGeneric2<PreHealInfo, EntityCore>._response GameEventListenerGeneric2<PreHealInfo, EntityCore>.OnEventRaised(PreHealInfo, EntityCore)"
  },
  "api/ElectricDrill.AstraRpgHealth.Events.html": {
    "href": "api/ElectricDrill.AstraRpgHealth.Events.html",
    "title": "Namespace ElectricDrill.AstraRpgHealth.Events | Astra RPG Health",
    "summary": "Namespace ElectricDrill.AstraRpgHealth.Events Classes DamageResolutionGameEvent Used to notify whether a damage was applied or prevented. DamageResolutionGameEventListener Used to notify whether a damage was applied or prevented. EntityDiedGameEvent The entity died. EntityDiedGameEventListener The entity died. EntityGainedHealthGameEvent The entity gained some health. EntityGainedHealthGameEventListener The entity gained some health. EntityHealedGameEvent The entity received an healing. EntityHealedGameEventListener The entity received an healing. EntityLostHealthGameEvent The entity lost some health. EntityLostHealthGameEventListener The entity lost some health. EntityMaxHealthChangedGameEvent The entity whose Max HP changed, the new Max HP, and the old Max HP. EntityMaxHealthChangedGameEventListener The entity whose Max HP changed, the new Max HP, and the old Max HP. EntityResurrectedGameEvent The entity resurrected with the specified amount of health. EntityResurrectedGameEventListener The entity resurrected with the specified amount of health. PreDmgGameEvent PreDmgGameEventListener PreHealGameEvent THe entity is about to be healed. PreHealGameEventListener THe entity is about to be healed."
  },
  "api/ElectricDrill.AstraRpgHealth.Exceptions.DeadEntityException.html": {
    "href": "api/ElectricDrill.AstraRpgHealth.Exceptions.DeadEntityException.html",
    "title": "Class DeadEntityException | Astra RPG Health",
    "summary": "Class DeadEntityException Namespace ElectricDrill.AstraRpgHealth.Exceptions Assembly com.electricdrill.astra-rpg-health.Runtime.dll Exception thrown when attempting to perform health-modifying operations on a dead entity. This exception indicates a programming error where the caller attempted to heal, damage, or otherwise modify the health of an entity that has already died. public class DeadEntityException : InvalidOperationException Inheritance object Exception SystemException InvalidOperationException DeadEntityException Constructors DeadEntityException(string, long, long, string) Initializes a new instance of the DeadEntityException class. public DeadEntityException(string entityName, long currentHp, long deathThreshold, string attemptedOperation) Parameters entityName string The name of the dead entity. currentHp long The current health points of the entity. deathThreshold long The death threshold value. attemptedOperation string The operation that was attempted. Properties AttemptedOperation Gets the operation that was attempted on the dead entity. public string AttemptedOperation { get; } Property Value string CurrentHp Gets the current health points of the dead entity. public long CurrentHp { get; } Property Value long DeathThreshold Gets the death threshold of the entity (health value at or below which the entity is considered dead). public long DeathThreshold { get; } Property Value long EntityName Gets the name of the entity that was dead when the operation was attempted. public string EntityName { get; } Property Value string"
  },
  "api/ElectricDrill.AstraRpgHealth.Exceptions.html": {
    "href": "api/ElectricDrill.AstraRpgHealth.Exceptions.html",
    "title": "Namespace ElectricDrill.AstraRpgHealth.Exceptions | Astra RPG Health",
    "summary": "Namespace ElectricDrill.AstraRpgHealth.Exceptions Classes DeadEntityException Exception thrown when attempting to perform health-modifying operations on a dead entity. This exception indicates a programming error where the caller attempted to heal, damage, or otherwise modify the health of an entity that has already died."
  },
  "api/ElectricDrill.AstraRpgHealth.Experience.ExpCollector.html": {
    "href": "api/ElectricDrill.AstraRpgHealth.Experience.ExpCollector.html",
    "title": "Class ExpCollector | Astra RPG Health",
    "summary": "Class ExpCollector Namespace ElectricDrill.AstraRpgHealth.Experience Assembly com.electricdrill.astra-rpg-health.Runtime.dll Collects experience when this entity deals killing blows. Requires an EntityDiedGameEventListener on the GameObject. [RequireComponent(typeof(EntityDiedGameEventListener))] public class ExpCollector : MonoBehaviour Inheritance object Object Component Behaviour MonoBehaviour ExpCollector Methods CheckCollectKillExp(EntityHealth, DamageResolution) Check whether the provided damage info represents a kill performed by this entity and collect experience if the victim is an experience source. public void CheckCollectKillExp(EntityHealth entityHealth, DamageResolution dmgInfo) Parameters entityHealth EntityHealth The health component of the entity that died. dmgInfo DamageResolution Damage resolution information that produced the death. CollectExp(IExpSource) Adds the experience provided by the given ElectricDrill.AstraRpgFramework.Experience.IExpSource to this entity's level component. public void CollectExp(IExpSource expSource) Parameters expSource IExpSource The experience source that provides the amount to collect."
  },
  "api/ElectricDrill.AstraRpgHealth.Experience.html": {
    "href": "api/ElectricDrill.AstraRpgHealth.Experience.html",
    "title": "Namespace ElectricDrill.AstraRpgHealth.Experience | Astra RPG Health",
    "summary": "Namespace ElectricDrill.AstraRpgHealth.Experience Classes ExpCollector Collects experience when this entity deals killing blows. Requires an EntityDiedGameEventListener on the GameObject."
  },
  "api/ElectricDrill.AstraRpgHealth.Heal.HealAmountInfo.html": {
    "href": "api/ElectricDrill.AstraRpgHealth.Heal.HealAmountInfo.html",
    "title": "Class HealAmountInfo | Astra RPG Health",
    "summary": "Class HealAmountInfo Namespace ElectricDrill.AstraRpgHealth.Heal Assembly com.electricdrill.astra-rpg-health.Runtime.dll Represents the different numeric stages of a heal amount as it is processed: the raw requested amount, the amount after applying a heal modifier, and the final net amount applied. public class HealAmountInfo Inheritance object HealAmountInfo Constructors HealAmountInfo(long, long, long) Create a new instance describing the provided heal values. public HealAmountInfo(long rawAmount, long afterModifierAmount, long netAmount) Parameters rawAmount long The initial requested heal amount. afterModifierAmount long The amount after applying modifier/stat adjustments. netAmount long The final amount actually applied to the target's health. Properties AfterModifierAmount Gets the healing amount after being modified by the associated heal modifier statistic. public long AfterModifierAmount { get; } Property Value long NetAmount Gets the actual amount of health added to the entity, considering the entity's maximum health. public long NetAmount { get; } Property Value long RawAmount Gets the initial healing amount derived directly from PreHealInfo. public long RawAmount { get; } Property Value long"
  },
  "api/ElectricDrill.AstraRpgHealth.Heal.HealSource.html": {
    "href": "api/ElectricDrill.AstraRpgHealth.Heal.HealSource.html",
    "title": "Class HealSource | Astra RPG Health",
    "summary": "Class HealSource Namespace ElectricDrill.AstraRpgHealth.Heal Assembly com.electricdrill.astra-rpg-health.Runtime.dll Defines a heal source asset that identifies how a heal was produced (e.g. spell, potion, resurrection, system, ...). Create instances via Assets -> Create -> Astra RPG Health / Heal Source. [CreateAssetMenu(fileName = \"New Heal Source\", menuName = \"Astra RPG Health/Heal Source\")] public class HealSource : ScriptableObject Inheritance object Object ScriptableObject HealSource Methods ToString() Returns the asset name of this heal source. public override string ToString() Returns string"
  },
  "api/ElectricDrill.AstraRpgHealth.Heal.IHealable.html": {
    "href": "api/ElectricDrill.AstraRpgHealth.Heal.IHealable.html",
    "title": "Interface IHealable | Astra RPG Health",
    "summary": "Interface IHealable Namespace ElectricDrill.AstraRpgHealth.Heal Assembly com.electricdrill.astra-rpg-health.Runtime.dll Interface for entities that can receive healing. Implementers apply healing based on the provided PreHealInfo. public interface IHealable Methods Heal(PreHealInfo) Apply a heal described by info and return information about the received heal. ReceivedHealInfo Heal(PreHealInfo info) Parameters info PreHealInfo Pre-heal context used to compute the actual heal applied. Returns ReceivedHealInfo A ReceivedHealInfo describing what was actually applied to the target."
  },
  "api/ElectricDrill.AstraRpgHealth.Heal.LifestealAmountSelector.html": {
    "href": "api/ElectricDrill.AstraRpgHealth.Heal.LifestealAmountSelector.html",
    "title": "Class LifestealAmountSelector | Astra RPG Health",
    "summary": "Class LifestealAmountSelector Namespace ElectricDrill.AstraRpgHealth.Heal Assembly com.electricdrill.astra-rpg-health.Runtime.dll Selects which damage amount will be used as the basis for lifesteal calculations. [Serializable] public class LifestealAmountSelector Inheritance object LifestealAmountSelector Constructors LifestealAmountSelector() Initializes a new instance of LifestealAmountSelector using default values. public LifestealAmountSelector() LifestealAmountSelector(LifestealBasisMode, string, StepValuePoint) Initializes a new instance of LifestealAmountSelector with the specified selection mode, optional pipeline step type name and step value point. public LifestealAmountSelector(LifestealBasisMode mode, string stepTypeName, StepValuePoint stepPoint) Parameters mode LifestealBasisMode Which basis to use (Initial, Step, Final). stepTypeName string Assembly-qualified or simple type name of the pipeline step to sample when Step is used. stepPoint StepValuePoint Whether to use the pre-step or post-step value when sampling a step. Properties Mode Gets or sets the basis mode used to select the damage amount for lifesteal. public LifestealBasisMode Mode { get; set; } Property Value LifestealBasisMode StepPoint Gets or sets whether to use the pre-step or post-step recorded value when sampling a pipeline step. public StepValuePoint StepPoint { get; set; } Property Value StepValuePoint StepType Gets or sets the System.Type of the pipeline step to sample when Mode is Step. Setting this property stores the assembly-qualified name; getting the property resolves the stored name to a runtime System.Type. public Type StepType { get; set; } Property Value Type Methods Evaluate(DamageAmountInfo) Evaluates the damage amounts and returns the long value that should be used for lifesteal according to this selector. public long Evaluate(DamageAmountInfo amounts) Parameters amounts DamageAmountInfo DamageAmountInfo instance containing initial, current and per-step records. Returns long The selected damage value to compute lifesteal from."
  },
  "api/ElectricDrill.AstraRpgHealth.Heal.LifestealBasisMode.html": {
    "href": "api/ElectricDrill.AstraRpgHealth.Heal.LifestealBasisMode.html",
    "title": "Enum LifestealBasisMode | Astra RPG Health",
    "summary": "Enum LifestealBasisMode Namespace ElectricDrill.AstraRpgHealth.Heal Assembly com.electricdrill.astra-rpg-health.Runtime.dll Specifies which damage value should be used as the basis for lifesteal calculations. [Serializable] public enum LifestealBasisMode Fields Final = 2 Use the final damage amount (after all pipeline steps). Initial = 0 Use the initial damage amount (before any pipeline modifications). Step = 1 Use the damage recorded at a specific pipeline step (requires a step type)."
  },
  "api/ElectricDrill.AstraRpgHealth.Heal.LifestealConfig.html": {
    "href": "api/ElectricDrill.AstraRpgHealth.Heal.LifestealConfig.html",
    "title": "Class LifestealConfig | Astra RPG Health",
    "summary": "Class LifestealConfig Namespace ElectricDrill.AstraRpgHealth.Heal Assembly com.electricdrill.astra-rpg-health.Runtime.dll ScriptableObject for configuring lifesteal mappings for different damage types. [CreateAssetMenu(fileName = \"New Lifesteal Config\", menuName = \"Astra RPG Health/Lifesteal Config\")] public class LifestealConfig : ScriptableObject Inheritance object Object ScriptableObject LifestealConfig Properties LifestealMappings Read-only mapping from DamageType to LifestealStatConfig. public IReadOnlyDictionary<DamageType, LifestealStatConfig> LifestealMappings { get; } Property Value IReadOnlyDictionary<DamageType, LifestealStatConfig> Remarks The dictionary is guaranteed to be non-null when accessed; calling code can safely enumerate it."
  },
  "api/ElectricDrill.AstraRpgHealth.Heal.LifestealStatConfig.html": {
    "href": "api/ElectricDrill.AstraRpgHealth.Heal.LifestealStatConfig.html",
    "title": "Class LifestealStatConfig | Astra RPG Health",
    "summary": "Class LifestealStatConfig Namespace ElectricDrill.AstraRpgHealth.Heal Assembly com.electricdrill.astra-rpg-health.Runtime.dll Configuration that associates a lifesteal Stat and HealSource with an optional amount selector. [Serializable] public class LifestealStatConfig Inheritance object LifestealStatConfig Properties AmountSelector Selector that determines which damage amount (initial/step/final) is used to compute the heal. public LifestealAmountSelector AmountSelector { get; } Property Value LifestealAmountSelector LifestealSource The HealSource that will be used when applying lifesteal. public HealSource LifestealSource { get; } Property Value HealSource LifestealStat The Stat that will receive lifesteal when this mapping is used. public Stat LifestealStat { get; } Property Value Stat"
  },
  "api/ElectricDrill.AstraRpgHealth.Heal.PreHealInfo.HealInfoAmount.html": {
    "href": "api/ElectricDrill.AstraRpgHealth.Heal.PreHealInfo.HealInfoAmount.html",
    "title": "Interface PreHealInfo.HealInfoAmount | Astra RPG Health",
    "summary": "Interface PreHealInfo.HealInfoAmount Namespace ElectricDrill.AstraRpgHealth.Heal Assembly com.electricdrill.astra-rpg-health.Runtime.dll Builder step interface for specifying the heal amount. public interface PreHealInfo.HealInfoAmount Methods WithAmount(long) Specify the base heal amount. PreHealInfo.HealInfoSource WithAmount(long amount) Parameters amount long Returns PreHealInfo.HealInfoSource"
  },
  "api/ElectricDrill.AstraRpgHealth.Heal.PreHealInfo.HealInfoHealer.html": {
    "href": "api/ElectricDrill.AstraRpgHealth.Heal.PreHealInfo.HealInfoHealer.html",
    "title": "Interface PreHealInfo.HealInfoHealer | Astra RPG Health",
    "summary": "Interface PreHealInfo.HealInfoHealer Namespace ElectricDrill.AstraRpgHealth.Heal Assembly com.electricdrill.astra-rpg-health.Runtime.dll Builder step interface for specifying the healer entity and optional extras. public interface PreHealInfo.HealInfoHealer Methods WithHealer(EntityCore) Specify the entity that performed the heal. PreHealInfo.PreHealInfoStepBuilder WithHealer(EntityCore healer) Parameters healer EntityCore Returns PreHealInfo.PreHealInfoStepBuilder"
  },
  "api/ElectricDrill.AstraRpgHealth.Heal.PreHealInfo.HealInfoSource.html": {
    "href": "api/ElectricDrill.AstraRpgHealth.Heal.PreHealInfo.HealInfoSource.html",
    "title": "Interface PreHealInfo.HealInfoSource | Astra RPG Health",
    "summary": "Interface PreHealInfo.HealInfoSource Namespace ElectricDrill.AstraRpgHealth.Heal Assembly com.electricdrill.astra-rpg-health.Runtime.dll Builder step interface for specifying the heal source. public interface PreHealInfo.HealInfoSource Methods WithSource(HealSource) Specify the HealSource for the heal. PreHealInfo.HealInfoHealer WithSource(HealSource healSource) Parameters healSource HealSource Returns PreHealInfo.HealInfoHealer"
  },
  "api/ElectricDrill.AstraRpgHealth.Heal.PreHealInfo.PreHealInfoStepBuilder.html": {
    "href": "api/ElectricDrill.AstraRpgHealth.Heal.PreHealInfo.PreHealInfoStepBuilder.html",
    "title": "Class PreHealInfo.PreHealInfoStepBuilder | Astra RPG Health",
    "summary": "Class PreHealInfo.PreHealInfoStepBuilder Namespace ElectricDrill.AstraRpgHealth.Heal Assembly com.electricdrill.astra-rpg-health.Runtime.dll Concrete builder implementing the fluent step interfaces to construct a PreHealInfo. public sealed class PreHealInfo.PreHealInfoStepBuilder : PreHealInfo.HealInfoAmount, PreHealInfo.HealInfoSource, PreHealInfo.HealInfoHealer Inheritance object PreHealInfo.PreHealInfoStepBuilder Implements PreHealInfo.HealInfoAmount PreHealInfo.HealInfoSource PreHealInfo.HealInfoHealer Methods Build() Build and return the configured PreHealInfo. public PreHealInfo Build() Returns PreHealInfo WithAmount(long) Set the base heal amount. public PreHealInfo.HealInfoSource WithAmount(long amount) Parameters amount long Returns PreHealInfo.HealInfoSource WithCriticalMultiplier(double) Set the critical multiplier applied when IsCritical is true. public PreHealInfo.PreHealInfoStepBuilder WithCriticalMultiplier(double multiplier) Parameters multiplier double Returns PreHealInfo.PreHealInfoStepBuilder WithHealer(EntityCore) Set the entity that performed the heal. public PreHealInfo.PreHealInfoStepBuilder WithHealer(EntityCore healer) Parameters healer EntityCore Returns PreHealInfo.PreHealInfoStepBuilder WithIsCritical(bool) Mark the built PreHealInfo as critical or not. public PreHealInfo.PreHealInfoStepBuilder WithIsCritical(bool isCritical) Parameters isCritical bool Returns PreHealInfo.PreHealInfoStepBuilder WithSource(HealSource) Set the heal source. public PreHealInfo.HealInfoHealer WithSource(HealSource healSource) Parameters healSource HealSource Returns PreHealInfo.HealInfoHealer"
  },
  "api/ElectricDrill.AstraRpgHealth.Heal.PreHealInfo.html": {
    "href": "api/ElectricDrill.AstraRpgHealth.Heal.PreHealInfo.html",
    "title": "Class PreHealInfo | Astra RPG Health",
    "summary": "Class PreHealInfo Namespace ElectricDrill.AstraRpgHealth.Heal Assembly com.electricdrill.astra-rpg-health.Runtime.dll Immutable description of a pending heal operation that can be passed through heal processing logic before the actual health change is applied. public class PreHealInfo Inheritance object PreHealInfo Properties Amount The requested heal amount (base value before modifiers). public long Amount { get; } Property Value long Builder Fluent builder entry point for creating a PreHealInfo. Use the returned builder to set amount, source and healer. public static PreHealInfo.HealInfoAmount Builder { get; } Property Value PreHealInfo.HealInfoAmount CriticalMultiplier The multiplicative factor applied when IsCritical is true. public double CriticalMultiplier { get; } Property Value double HealSource The HealSource identifying the origin/type of the heal. public HealSource HealSource { get; } Property Value HealSource Healer The entity that caused the heal (may be null for non-entity sources). public EntityCore Healer { get; } Property Value EntityCore IsCritical Whether this heal is flagged as a critical heal. public bool IsCritical { get; } Property Value bool"
  },
  "api/ElectricDrill.AstraRpgHealth.Heal.ReceivedHealInfo.HealInfoAmount.html": {
    "href": "api/ElectricDrill.AstraRpgHealth.Heal.ReceivedHealInfo.HealInfoAmount.html",
    "title": "Interface ReceivedHealInfo.HealInfoAmount | Astra RPG Health",
    "summary": "Interface ReceivedHealInfo.HealInfoAmount Namespace ElectricDrill.AstraRpgHealth.Heal Assembly com.electricdrill.astra-rpg-health.Runtime.dll Builder step: provide the heal amount. public interface ReceivedHealInfo.HealInfoAmount Methods WithAmount(HealAmountInfo) Continue building by specifying the resolved HealAmountInfo. ReceivedHealInfo.HealInfoSource WithAmount(HealAmountInfo healAmount) Parameters healAmount HealAmountInfo Returns ReceivedHealInfo.HealInfoSource"
  },
  "api/ElectricDrill.AstraRpgHealth.Heal.ReceivedHealInfo.HealInfoHealer.html": {
    "href": "api/ElectricDrill.AstraRpgHealth.Heal.ReceivedHealInfo.HealInfoHealer.html",
    "title": "Interface ReceivedHealInfo.HealInfoHealer | Astra RPG Health",
    "summary": "Interface ReceivedHealInfo.HealInfoHealer Namespace ElectricDrill.AstraRpgHealth.Heal Assembly com.electricdrill.astra-rpg-health.Runtime.dll Builder step: provide the healer entity. public interface ReceivedHealInfo.HealInfoHealer Methods WithHealer(EntityCore) Continue building by specifying the healer ElectricDrill.AstraRpgFramework.EntityCore. ReceivedHealInfo.HealInfoTarget WithHealer(EntityCore healer) Parameters healer EntityCore Returns ReceivedHealInfo.HealInfoTarget"
  },
  "api/ElectricDrill.AstraRpgHealth.Heal.ReceivedHealInfo.HealInfoSource.html": {
    "href": "api/ElectricDrill.AstraRpgHealth.Heal.ReceivedHealInfo.HealInfoSource.html",
    "title": "Interface ReceivedHealInfo.HealInfoSource | Astra RPG Health",
    "summary": "Interface ReceivedHealInfo.HealInfoSource Namespace ElectricDrill.AstraRpgHealth.Heal Assembly com.electricdrill.astra-rpg-health.Runtime.dll Builder step: provide the heal source. public interface ReceivedHealInfo.HealInfoSource Methods WithSource(HealSource) Continue building by specifying the HealSource. ReceivedHealInfo.HealInfoHealer WithSource(HealSource healSource) Parameters healSource HealSource Returns ReceivedHealInfo.HealInfoHealer"
  },
  "api/ElectricDrill.AstraRpgHealth.Heal.ReceivedHealInfo.HealInfoTarget.html": {
    "href": "api/ElectricDrill.AstraRpgHealth.Heal.ReceivedHealInfo.HealInfoTarget.html",
    "title": "Interface ReceivedHealInfo.HealInfoTarget | Astra RPG Health",
    "summary": "Interface ReceivedHealInfo.HealInfoTarget Namespace ElectricDrill.AstraRpgHealth.Heal Assembly com.electricdrill.astra-rpg-health.Runtime.dll Builder step: provide the target entity and finalize options. public interface ReceivedHealInfo.HealInfoTarget Methods WithTarget(EntityCore) Final builder step: specify the target, which returns the step builder for optional flags and build. ReceivedHealInfo.ReceivedHealInfoStepBuilder WithTarget(EntityCore target) Parameters target EntityCore Returns ReceivedHealInfo.ReceivedHealInfoStepBuilder"
  },
  "api/ElectricDrill.AstraRpgHealth.Heal.ReceivedHealInfo.ReceivedHealInfoStepBuilder.html": {
    "href": "api/ElectricDrill.AstraRpgHealth.Heal.ReceivedHealInfo.ReceivedHealInfoStepBuilder.html",
    "title": "Class ReceivedHealInfo.ReceivedHealInfoStepBuilder | Astra RPG Health",
    "summary": "Class ReceivedHealInfo.ReceivedHealInfoStepBuilder Namespace ElectricDrill.AstraRpgHealth.Heal Assembly com.electricdrill.astra-rpg-health.Runtime.dll Concrete fluent builder used to assemble a ReceivedHealInfo. Use Builder to start. public sealed class ReceivedHealInfo.ReceivedHealInfoStepBuilder : ReceivedHealInfo.HealInfoAmount, ReceivedHealInfo.HealInfoSource, ReceivedHealInfo.HealInfoHealer, ReceivedHealInfo.HealInfoTarget Inheritance object ReceivedHealInfo.ReceivedHealInfoStepBuilder Implements ReceivedHealInfo.HealInfoAmount ReceivedHealInfo.HealInfoSource ReceivedHealInfo.HealInfoHealer ReceivedHealInfo.HealInfoTarget Properties Builder Starts a new builder for ReceivedHealInfo. public static ReceivedHealInfo.HealInfoAmount Builder { get; } Property Value ReceivedHealInfo.HealInfoAmount Methods Build() Build the final ReceivedHealInfo instance. public ReceivedHealInfo Build() Returns ReceivedHealInfo WithAmount(HealAmountInfo) Set the resolved HealAmountInfo. public ReceivedHealInfo.HealInfoSource WithAmount(HealAmountInfo healAmount) Parameters healAmount HealAmountInfo Returns ReceivedHealInfo.HealInfoSource WithHealer(EntityCore) Set the entity that performed the heal. public ReceivedHealInfo.HealInfoTarget WithHealer(EntityCore healer) Parameters healer EntityCore Returns ReceivedHealInfo.HealInfoTarget WithIsCritical(bool) Optionally mark the heal as critical. public ReceivedHealInfo.ReceivedHealInfoStepBuilder WithIsCritical(bool isCritical) Parameters isCritical bool Returns ReceivedHealInfo.ReceivedHealInfoStepBuilder WithSource(HealSource) Set the HealSource for the heal. public ReceivedHealInfo.HealInfoHealer WithSource(HealSource healSource) Parameters healSource HealSource Returns ReceivedHealInfo.HealInfoHealer WithTarget(EntityCore) Set the entity that will receive the heal. Returns the builder for optional flags. public ReceivedHealInfo.ReceivedHealInfoStepBuilder WithTarget(EntityCore target) Parameters target EntityCore Returns ReceivedHealInfo.ReceivedHealInfoStepBuilder"
  },
  "api/ElectricDrill.AstraRpgHealth.Heal.ReceivedHealInfo.html": {
    "href": "api/ElectricDrill.AstraRpgHealth.Heal.ReceivedHealInfo.html",
    "title": "Class ReceivedHealInfo | Astra RPG Health",
    "summary": "Class ReceivedHealInfo Namespace ElectricDrill.AstraRpgHealth.Heal Assembly com.electricdrill.astra-rpg-health.Runtime.dll Represents the result of a heal operation as actually received by the target. Contains the resolved heal amount, source, involved entities and whether it was critical. public class ReceivedHealInfo Inheritance object ReceivedHealInfo Constructors ReceivedHealInfo(HealAmountInfo, PreHealInfo, EntityCore) Create a ReceivedHealInfo from the computed heal amount and the pre-heal context. public ReceivedHealInfo(HealAmountInfo healAmount, PreHealInfo preHealInfo, EntityCore target) Parameters healAmount HealAmountInfo Resolved heal amount information. preHealInfo PreHealInfo Pre-heal context that produced metadata such as source and healer. target EntityCore Entity that will receive the heal. Properties Builder Entry point to build a ReceivedHealInfo using a step builder. public static ReceivedHealInfo.HealInfoAmount Builder { get; } Property Value ReceivedHealInfo.HealInfoAmount HealAmount The calculated heal amount that will be applied to the target. public HealAmountInfo HealAmount { get; } Property Value HealAmountInfo HealSource The HealSource that produced this heal. public HealSource HealSource { get; } Property Value HealSource Healer The entity that performed the heal (may be null for system heals). public EntityCore Healer { get; } Property Value EntityCore IsCritical True if the heal was a critical heal. public bool IsCritical { get; } Property Value bool Target The entity that receives the heal. public EntityCore Target { get; } Property Value EntityCore"
  },
  "api/ElectricDrill.AstraRpgHealth.Heal.StepValuePoint.html": {
    "href": "api/ElectricDrill.AstraRpgHealth.Heal.StepValuePoint.html",
    "title": "Enum StepValuePoint | Astra RPG Health",
    "summary": "Enum StepValuePoint Namespace ElectricDrill.AstraRpgHealth.Heal Assembly com.electricdrill.astra-rpg-health.Runtime.dll Selects whether to use the pre-step or post-step value when Step is selected. [Serializable] public enum StepValuePoint Fields Post = 1 Use the value recorded after the pipeline step executes. Pre = 0 Use the value recorded before the pipeline step executes."
  },
  "api/ElectricDrill.AstraRpgHealth.Heal.html": {
    "href": "api/ElectricDrill.AstraRpgHealth.Heal.html",
    "title": "Namespace ElectricDrill.AstraRpgHealth.Heal | Astra RPG Health",
    "summary": "Namespace ElectricDrill.AstraRpgHealth.Heal Classes HealAmountInfo Represents the different numeric stages of a heal amount as it is processed: the raw requested amount, the amount after applying a heal modifier, and the final net amount applied. HealSource Defines a heal source asset that identifies how a heal was produced (e.g. spell, potion, resurrection, system, ...). Create instances via Assets -> Create -> Astra RPG Health / Heal Source. LifestealAmountSelector Selects which damage amount will be used as the basis for lifesteal calculations. LifestealConfig ScriptableObject for configuring lifesteal mappings for different damage types. LifestealStatConfig Configuration that associates a lifesteal Stat and HealSource with an optional amount selector. PreHealInfo Immutable description of a pending heal operation that can be passed through heal processing logic before the actual health change is applied. PreHealInfo.PreHealInfoStepBuilder Concrete builder implementing the fluent step interfaces to construct a PreHealInfo. ReceivedHealInfo Represents the result of a heal operation as actually received by the target. Contains the resolved heal amount, source, involved entities and whether it was critical. ReceivedHealInfo.ReceivedHealInfoStepBuilder Concrete fluent builder used to assemble a ReceivedHealInfo. Use Builder to start. Interfaces IHealable Interface for entities that can receive healing. Implementers apply healing based on the provided PreHealInfo. PreHealInfo.HealInfoAmount Builder step interface for specifying the heal amount. PreHealInfo.HealInfoHealer Builder step interface for specifying the healer entity and optional extras. PreHealInfo.HealInfoSource Builder step interface for specifying the heal source. ReceivedHealInfo.HealInfoAmount Builder step: provide the heal amount. ReceivedHealInfo.HealInfoHealer Builder step: provide the healer entity. ReceivedHealInfo.HealInfoSource Builder step: provide the heal source. ReceivedHealInfo.HealInfoTarget Builder step: provide the target entity and finalize options. Enums LifestealBasisMode Specifies which damage value should be used as the basis for lifesteal calculations. StepValuePoint Selects whether to use the pre-step or post-step value when Step is selected."
  },
  "api/ElectricDrill.AstraRpgHealth.Resurrection.DoNothingOnResurrectionStrategy.html": {
    "href": "api/ElectricDrill.AstraRpgHealth.Resurrection.DoNothingOnResurrectionStrategy.html",
    "title": "Class DoNothingOnResurrectionStrategy | Astra RPG Health",
    "summary": "Class DoNothingOnResurrectionStrategy Namespace ElectricDrill.AstraRpgHealth.Resurrection Assembly com.electricdrill.astra-rpg-health.Runtime.dll A no-op resurrection strategy. Use this when no action is required upon an entity's resurrection. Provided as a ScriptableObject for easy assignment in the editor. Create instances via Assets -> Create -> Astra RPG Health / Resurrection strategies / Do Nothing. [CreateAssetMenu(fileName = \"Do Nothing On Resurrection Strategy\", menuName = \"Astra RPG Health/Resurrection strategies/Do Nothing\")] public class DoNothingOnResurrectionStrategy : OnResurrectionStrategy Inheritance object Object ScriptableObject OnResurrectionStrategy DoNothingOnResurrectionStrategy Methods Resurrect(EntityHealth) Intentionally performs no action when an entity is resurrected. public override void Resurrect(EntityHealth entityHealth) Parameters entityHealth EntityHealth The EntityHealth instance that is being resurrected (unused)."
  },
  "api/ElectricDrill.AstraRpgHealth.Resurrection.EnableOnResurrectionStrategy.html": {
    "href": "api/ElectricDrill.AstraRpgHealth.Resurrection.EnableOnResurrectionStrategy.html",
    "title": "Class EnableOnResurrectionStrategy | Astra RPG Health",
    "summary": "Class EnableOnResurrectionStrategy Namespace ElectricDrill.AstraRpgHealth.Resurrection Assembly com.electricdrill.astra-rpg-health.Runtime.dll A resurrection strategy that enables the entity's GameObject when it is resurrected. This is useful when using a death strategy that disables the GameObject (e.g., DisableOnDeathStrategy). Provided as a ScriptableObject for easy assignment in the editor. Create instances via Assets -> Create -> Astra RPG Health / Resurrection strategies / Enable. [CreateAssetMenu(fileName = \"Enable On Resurrection Strategy\", menuName = \"Astra RPG Health/Resurrection strategies/Enable\")] public class EnableOnResurrectionStrategy : OnResurrectionStrategy Inheritance object Object ScriptableObject OnResurrectionStrategy EnableOnResurrectionStrategy Methods Resurrect(EntityHealth) Enables the GameObject associated with entityHealth. public override void Resurrect(EntityHealth entityHealth) Parameters entityHealth EntityHealth The EntityHealth instance that is being resurrected."
  },
  "api/ElectricDrill.AstraRpgHealth.Resurrection.IResurrectable.html": {
    "href": "api/ElectricDrill.AstraRpgHealth.Resurrection.IResurrectable.html",
    "title": "Interface IResurrectable | Astra RPG Health",
    "summary": "Interface IResurrectable Namespace ElectricDrill.AstraRpgHealth.Resurrection Assembly com.electricdrill.astra-rpg-health.Runtime.dll public interface IResurrectable Methods Resurrect(Percentage, HealSource) Resurrects the entity with a percentage of its maximum HP. void Resurrect(Percentage withHpPercent, HealSource healSource) Parameters withHpPercent Percentage The percentage of maximum HP to resurrect with. healSource HealSource The heal source associated with the resurrection. Resurrect(long, HealSource) Resurrects the entity with a fixed amount of HP. void Resurrect(long withHp, HealSource healSource) Parameters withHp long The fixed amount of HP to resurrect with. healSource HealSource The heal source associated with the resurrection."
  },
  "api/ElectricDrill.AstraRpgHealth.Resurrection.MultipleOnResurrectionStrategy.html": {
    "href": "api/ElectricDrill.AstraRpgHealth.Resurrection.MultipleOnResurrectionStrategy.html",
    "title": "Class MultipleOnResurrectionStrategy | Astra RPG Health",
    "summary": "Class MultipleOnResurrectionStrategy Namespace ElectricDrill.AstraRpgHealth.Resurrection Assembly com.electricdrill.astra-rpg-health.Runtime.dll A resurrection strategy that executes multiple resurrection strategies in order. This allows combining multiple resurrection behaviors without creating new strategy classes. Provided as a ScriptableObject for easy assignment in the editor. Create instances via Assets -> Create -> Astra RPG Health / Resurrection strategies / Multiple. [CreateAssetMenu(fileName = \"Multiple On Resurrection Strategy\", menuName = \"Astra RPG Health/Resurrection strategies/Multiple\")] public class MultipleOnResurrectionStrategy : OnResurrectionStrategy Inheritance object Object ScriptableObject OnResurrectionStrategy MultipleOnResurrectionStrategy Methods Resurrect(EntityHealth) Executes all configured resurrection strategies in order. Null strategies in the list are skipped. public override void Resurrect(EntityHealth entityHealth) Parameters entityHealth EntityHealth The EntityHealth instance that is being resurrected."
  },
  "api/ElectricDrill.AstraRpgHealth.Resurrection.OnResurrectionStrategy.html": {
    "href": "api/ElectricDrill.AstraRpgHealth.Resurrection.OnResurrectionStrategy.html",
    "title": "Class OnResurrectionStrategy | Astra RPG Health",
    "summary": "Class OnResurrectionStrategy Namespace ElectricDrill.AstraRpgHealth.Resurrection Assembly com.electricdrill.astra-rpg-health.Runtime.dll Base strategy type for handling an entity's resurrection. Derive from this class and implement Resurrect(EntityHealth) to define custom resurrection behavior. public abstract class OnResurrectionStrategy : ScriptableObject Inheritance object Object ScriptableObject OnResurrectionStrategy Derived DoNothingOnResurrectionStrategy EnableOnResurrectionStrategy MultipleOnResurrectionStrategy Methods Resurrect(EntityHealth) Invoked when an entity should be resurrected. Implementations should perform any setup, state changes, or initialization logic here. public abstract void Resurrect(EntityHealth entityHealth) Parameters entityHealth EntityHealth The EntityHealth instance representing the entity that is being resurrected."
  },
  "api/ElectricDrill.AstraRpgHealth.Resurrection.ResurrectionInfo.html": {
    "href": "api/ElectricDrill.AstraRpgHealth.Resurrection.ResurrectionInfo.html",
    "title": "Class ResurrectionInfo | Astra RPG Health",
    "summary": "Class ResurrectionInfo Namespace ElectricDrill.AstraRpgHealth.Resurrection Assembly com.electricdrill.astra-rpg-health.Runtime.dll Contains information about an entity resurrection event. public class ResurrectionInfo Inheritance object ResurrectionInfo Constructors ResurrectionInfo(long, long, HealSource) Initializes a new instance of the ResurrectionInfo class. public ResurrectionInfo(long previousHp, long newHp, HealSource healSource) Parameters previousHp long The HP before resurrection. newHp long The HP after resurrection. healSource HealSource The heal source associated with the resurrection. Properties HealSource Gets the heal source associated with the resurrection. This can be used to categorize different types of resurrections (spell, item, phoenix down, etc.). public HealSource HealSource { get; } Property Value HealSource NewHp Gets the health points the entity was resurrected with. public long NewHp { get; } Property Value long PreviousHp Gets the health points the entity had before resurrection (typically at or below death threshold). public long PreviousHp { get; } Property Value long"
  },
  "api/ElectricDrill.AstraRpgHealth.Resurrection.html": {
    "href": "api/ElectricDrill.AstraRpgHealth.Resurrection.html",
    "title": "Namespace ElectricDrill.AstraRpgHealth.Resurrection | Astra RPG Health",
    "summary": "Namespace ElectricDrill.AstraRpgHealth.Resurrection Classes DoNothingOnResurrectionStrategy A no-op resurrection strategy. Use this when no action is required upon an entity's resurrection. Provided as a ScriptableObject for easy assignment in the editor. Create instances via Assets -> Create -> Astra RPG Health / Resurrection strategies / Do Nothing. EnableOnResurrectionStrategy A resurrection strategy that enables the entity's GameObject when it is resurrected. This is useful when using a death strategy that disables the GameObject (e.g., DisableOnDeathStrategy). Provided as a ScriptableObject for easy assignment in the editor. Create instances via Assets -> Create -> Astra RPG Health / Resurrection strategies / Enable. MultipleOnResurrectionStrategy A resurrection strategy that executes multiple resurrection strategies in order. This allows combining multiple resurrection behaviors without creating new strategy classes. Provided as a ScriptableObject for easy assignment in the editor. Create instances via Assets -> Create -> Astra RPG Health / Resurrection strategies / Multiple. OnResurrectionStrategy Base strategy type for handling an entity's resurrection. Derive from this class and implement Resurrect(EntityHealth) to define custom resurrection behavior. ResurrectionInfo Contains information about an entity resurrection event. Interfaces IResurrectable"
  },
  "api/ElectricDrill.AstraRpgHealth.Scaling.ScalingComponents.HealthScalingComponent.html": {
    "href": "api/ElectricDrill.AstraRpgHealth.Scaling.ScalingComponents.HealthScalingComponent.html",
    "title": "Class HealthScalingComponent | Astra RPG Health",
    "summary": "Class HealthScalingComponent Namespace ElectricDrill.AstraRpgHealth.Scaling.ScalingComponents Assembly com.electricdrill.astra-rpg-health.Runtime.dll A scaling component that calculates a value based on an entity's health values. public class HealthScalingComponent : ScalingComponent Inheritance object Object ScriptableObject ScalingComponent HealthScalingComponent Methods CalculateValue(EntityCore) Calculates the scaling value based on the entity's health component. public override long CalculateValue(EntityCore entity) Parameters entity EntityCore The entity to calculate the value for. Returns long The calculated scaling value."
  },
  "api/ElectricDrill.AstraRpgHealth.Scaling.ScalingComponents.HealthScalingComponentMenuItems.html": {
    "href": "api/ElectricDrill.AstraRpgHealth.Scaling.ScalingComponents.HealthScalingComponentMenuItems.html",
    "title": "Class HealthScalingComponentMenuItems | Astra RPG Health",
    "summary": "Class HealthScalingComponentMenuItems Namespace ElectricDrill.AstraRpgHealth.Scaling.ScalingComponents Assembly com.electricdrill.astra-rpg-health.Runtime.dll Provides a menu item in the Unity Editor to create a HealthScalingComponent asset. public static class HealthScalingComponentMenuItems Inheritance object HealthScalingComponentMenuItems"
  },
  "api/ElectricDrill.AstraRpgHealth.Scaling.ScalingComponents.html": {
    "href": "api/ElectricDrill.AstraRpgHealth.Scaling.ScalingComponents.html",
    "title": "Namespace ElectricDrill.AstraRpgHealth.Scaling.ScalingComponents | Astra RPG Health",
    "summary": "Namespace ElectricDrill.AstraRpgHealth.Scaling.ScalingComponents Classes HealthScalingComponent A scaling component that calculates a value based on an entity's health values. HealthScalingComponentMenuItems Provides a menu item in the Unity Editor to create a HealthScalingComponent asset."
  },
  "api/ElectricDrill.AstraRpgHealth.html": {
    "href": "api/ElectricDrill.AstraRpgHealth.html",
    "title": "Namespace ElectricDrill.AstraRpgHealth | Astra RPG Health",
    "summary": "Namespace ElectricDrill.AstraRpgHealth Classes EntityHealth Manages the health, damage, and healing mechanics for an entity. Handles damage calculation, health regeneration, barriers (temporary HP), and death events. Enums EntityHealth.HpBehaviourOnMaxHpDecrease EntityHealth.HpBehaviourOnMaxHpIncrease"
  },
  "index.html": {
    "href": "index.html",
    "title": "| Astra RPG Health",
    "summary": "Note Join the Astra RPG Discord server! There is now a dedicated Discord server for Astra RPG Framework and its extensions. Join to receive notifications about new extension releases and important updates, to ask for new features, report bugs, share ideas, and showcase your Astra creations with other developers. \uD83D\uDCAC Join the Discord Server: https://discord.gg/nJVRMkGrZg \uD83D\uDEE0️ Astra RPG Framework \uD83D\uDC49 Introduction Say goodbye to endless recompilations. Instantly balance your RPG's stats and formulas with a powerful data-driven system. Astra RPG Framework provides a complete, data-driven backbone for your RPG, letting you define your game's foundations directly in the editor and iterate on balance during play mode. Simple, lightweight, and easy to learn. No configuration required: works out of the box with zero setup. ✨ Key Features \uD83D\uDCCA Statistics & Attributes: Define the core building blocks for your game ⭐ Experience & Levels: Build a robust progression system \uD83E\uDDD1‍\uD83C\uDF93 Classes & Progression: Design custom classes and unique progression paths \uD83D\uDCC8 Scaling Formulas: Create complex formulas for damage, healing, and other values using entities' stats and attributes ⚡ Event System: Enable dynamic game-object interactions with inspector-wired events and listeners \uD83D\uDEE0️ Utilities: Helpful tools to streamline development. Ever used Int and Long variables as ScriptableObjects? Discover new possibilities! ⚙️ Implemented on top of ScriptableObjects architecture \uD83C\uDFA8 Designer-friendly: Most of the features are ScriptableObjects, easily created and wired in the Unity Inspector. Custom inspectors are available for everything. \uD83E\uDDE9 Reusable and modular: Objects can be reused across game objects and scenes. They are the building blocks for your game. Instantiate, compose, reuse. Changes instantly reflect on dependent objects. No duplication, no hassle. \uD83E\uDDEA Easy testing: Swap objects, switch from class-based stats to fixed ones, or replace complex formulas—all without leaving play mode. Debugging and testing is effortless. \uD83D\uDD0D Features Breakdown \uD83D\uDD78️ Attributes Attributes are the core numerical values that define an entity's capabilities. In most RPGs these include strength, dexterity, intelligence, constitution, etc. You define your own attributes, choosing their names and min/max values as needed. Group attributes into attribute sets—shareable objects reusable across entities. Supports both flat and percentage modifiers. \uD83D\uDCCA Statistics Statistics are derived values that directly affect gameplay, such as Physical Attack, Armor, Crit Chance, and movement speed. Define custom statistics and organize them into sets tailored for each entity. Statistic sets can be modular—for example, create separate sets for movement, offense, and defense, then assign only what's relevant to each entity. Statistics can scale with attributes. Define how each statistic scales based on one or more attributes. Like attributes, statistics can have lower and upper bounds. Statistics support flat and percentage modifiers, plus powerful stat-to-stat modifiers. Create buffs/debuffs that change a statistic based on another statistic's value. ⭐ Experience & Levels Define custom level progression curves and experience requirements for each level. If an entity doesn't level up, set fixed base stats and attributes. Set up simple entities in seconds. \uD83E\uDDD1‍\uD83C\uDF93 Classes & Progression Classes (like warrior, mage, rogue, etc.) let you define unique progression paths for attributes and statistics. Assign progression curves for each attribute and statistic to each class for distinct play styles. Balance progression curves in real-time—test and iterate instantly during play mode. \uD83D\uDCC8 Scaling Formulas Easily build complex formulas for damage, healing, and other values using stats and attributes. Drag and drop scaling components to visually assemble formulas in the custom inspector. Formulas are fully customizable. Set a fixed base value or make it scale dynamically with levels. Add scaling components to adjust values based on the caster’s or target’s stats and attributes—or both. Add and remove temporary scaling components at runtime for advanced mechanics. For example, a potion might grant \"Your next base attack deals extra damage equal to 50% of your Constitution.\" Drinking it adds a temporary scaling component to the base attack formula; after the attack, the temporary scaling component is removed. Reuse formulas across entities and scenarios for consistency and reduced redundancy. See the impact of changes instantly in play mode, enabling rapid iteration and fine-tuning of game balance. ⚡ Game Events Game events are ScriptableObjects. Instantiate events in your assets, then drag & drop them into scripts that raise them and into Game Event Listeners that define responses. Testing your game's logic from the inspector is easier than ever. The framework provides a set of predefined game events (and MonoBehaviour listeners) to get you started quickly: GameEvent: No context parameters. For simple events like 'Player Jumped', 'Player Slept', etc. IntGameEvent: One integer context parameter. EntityLeveledUpGameEvent: An event that carries along an EntityCore and an int as context parameters, where the EntityCore is the entity that leveled up and the int is the new level reached. StatChangedGameEvent: Notifies when a stat changes for a specific entity. AttributeChangedGameEvent: Notifies when an attribute changes for a specific entity. \uD83C\uDFED⚡ Game Event Generators Game Event Generators are powerful tools for generating C# source code for custom game events. Use the custom inspector to create new event types with up to 4 context parameters—these can be native C# types or your own classes. Game Event Generators are also ScriptableObjects. Instantiate multiple generators to organize different sets of events for your project. Each generator can manage its own context-specific events. \uD83D\uDED2 Where to Buy Unity Asset Store: Astra RPG \uD83D\uDCEC Information & Contact Questions, feedback, or bugs? Email us at electricdrill.info@gmail.com."
  }
}